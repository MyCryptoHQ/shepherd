{"version":3,"file":"shepherd.es6.js","sources":["../src/utils/idGenerator.ts","../src/ducks/providerBalancer/balancerConfig/types.ts","../src/ducks/providerBalancer/balancerConfig/actions.ts","../src/ducks/providerBalancer/balancerConfig/reducer.ts","../src/utils/logging.ts","../src/ducks/store.ts","../src/ducks/rootState.ts","../src/ducks/providerBalancer/selectors.ts","../src/ducks/providerBalancer/balancerConfig/selectors.ts","../src/ducks/providerBalancer/providerCalls/types.ts","../src/ducks/providerBalancer/providerCalls/actions.ts","../src/ducks/providerBalancer/providerCalls/selectors.ts","../src/ducks/providerBalancer/workers/types.ts","../src/ducks/providerBalancer/workers/actions.ts","../src/ducks/providerBalancer/workers/selectors.ts","../src/ducks/providerBalancer/providerStats/types.ts","../src/ducks/providerBalancer/providerStats/actions.ts","../src/ducks/providerBalancer/providerStats/selectors.ts","../src/ducks/providerBalancer/providerStats/reducer.ts","../src/ducks/providerBalancer/workers/reducer.ts","../src/ducks/providerBalancer/providerCalls/reducer.ts","../src/ducks/subscribe/types.ts","../src/ducks/subscribe/actions.ts","../src/ducks/subscribe/utils.ts","../src/ducks/providerConfigs/types.ts","../src/ducks/providerConfigs/reducer.ts","../src/ducks/providerConfigs/actions.ts","../src/utils/ethUnits.ts","../src/validators/index.ts","../src/providers/rpc/client.ts","../src/providers/rpc/requests.ts","../src/providers/rpc/index.ts","../src/providers/custom/index.ts","../src/providers/etherscan/client.ts","../src/providers/etherscan/requests.ts","../src/providers/etherscan/index.ts","../src/providers/infura/client.ts","../src/providers/infura/index.ts","../src/providers/web3/client.ts","../src/providers/web3/requests.ts","../src/providers/web3/index.ts","../src/providers/providerStorage.ts","../src/ducks/providerConfigs/selectors.ts","../src/providers/providerManager.ts","../src/providers/constants.ts","../src/providers/providerProxy.ts","../src/api.ts","../src/ducks/middleware.ts","../src/ducks/providerBalancer/index.ts","../src/saga/watchers/watchActionSubscription.ts","../src/saga/sagaUtils.ts","../src/saga/channels/base.ts","../src/saga/channels/balancerChannel.ts","../src/saga/channels/providerChannel.ts","../src/saga/channels/providerChannels.ts","../src/saga/channels/index.ts","../src/saga/workers/helpers.ts","../src/saga/workers/index.ts","../src/saga/helpers/connectivity.ts","../src/saga/helpers/processing.ts","../src/saga/watchers/watchAddingProviders.ts","../src/saga/watchers/watchBalancerFlush.ts","../src/ducks/utils.ts","../src/ducks/selectors.ts","../src/saga/watchers/watchBalancerHealth.ts","../src/saga/watchers/watchCallTimeouts.ts","../src/saga/watchers/watchManualMode.ts","../src/saga/watchers/watchNetworkSwitches/helpers.ts","../src/saga/watchers/watchNetworkSwitches/index.ts","../src/saga/watchers/watchProviderCalls.ts","../src/saga/watchers/watchProviderHealth/helpers.ts","../src/saga/watchers/watchProviderHealth/index.ts","../src/saga/watchers/index.ts","../src/saga/index.ts","../src/ducks/index.ts"],"sourcesContent":["export const idGeneratorFactory = () => {\n  let callId = 0;\n  return () => {\n    const currValue = callId;\n    callId += 1;\n    return currValue;\n  };\n};\n","import { IProviderBalancerState } from '@src/ducks/providerBalancer';\n\nexport enum BALANCER {\n  NETWORK_SWTICH_REQUESTED = 'BALANCER_NETWORK_SWTICH_REQUESTED',\n  NETWORK_SWITCH_SUCCEEDED = 'BALANCER_NETWORK_SWITCH_SUCCEEDED',\n  SET_PROVIDER_CALL_RETRY_THRESHOLD = 'BALANCER_SET_PROVIDER_CALL_RETRY_THRESHOLD',\n  INIT = 'BALANCER_INIT',\n  FLUSH = 'BALANCER_FLUSH',\n  AUTO = 'BALANCER_AUTO',\n  MANUAL_REQUESTED = 'BALANCER_MANUAL_REQUESTED',\n  MANUAL_SUCCEEDED = 'BALANCER_MANUAL_SUCCEEDED',\n  MANUAL_FAILED = 'BALANCER_MANUAL_FAILED',\n\n  OFFLINE = 'BALANCER_OFFLINE',\n  ONLINE = 'BALANCER_ONLINE',\n  QUEUE_TIMEOUT = 'QUEUE_TIMEOUT',\n}\n\nexport type BalancerConfigInitConfig = Partial<{\n  providerCallRetryThreshold: number;\n  network: string;\n  queueTimeout: number;\n}>;\n\nexport interface IBalancerConfigState {\n  network: string;\n  manual: false | string;\n  offline: boolean;\n  queueTimeout: number;\n  providerCallRetryThreshold: number;\n  networkSwitchPending: boolean;\n}\n\nexport interface IBalancerInit {\n  type: BALANCER.INIT;\n  payload: BalancerConfigInitConfig;\n  meta: { id: number };\n}\n\nexport interface IBalancerFlush {\n  type: BALANCER.FLUSH;\n}\n\nexport interface IBalancerQueueTimeout {\n  type: BALANCER.QUEUE_TIMEOUT;\n}\n\nexport interface IBalancerNetworkSwitchRequested {\n  type: BALANCER.NETWORK_SWTICH_REQUESTED;\n  payload: { network: string };\n  meta: { id: number };\n}\n\nexport interface IBalancerNetworkSwitchSucceeded {\n  type: BALANCER.NETWORK_SWITCH_SUCCEEDED;\n  payload: {\n    providerStats: IProviderBalancerState['providerStats'];\n    workers: IProviderBalancerState['workers'];\n    network: string;\n  };\n  meta: { id: number };\n}\n\nexport interface IBalancerSetProviderCallRetryThreshold {\n  type: BALANCER.SET_PROVIDER_CALL_RETRY_THRESHOLD;\n  payload: {\n    threshold: number;\n  };\n}\n\nexport interface IBalancerOffline {\n  type: BALANCER.OFFLINE;\n}\n\nexport interface IBalancerOnline {\n  type: BALANCER.ONLINE;\n}\n\nexport interface IBalancerAuto {\n  type: BALANCER.AUTO;\n}\n\nexport interface IBalancerManualRequested {\n  type: BALANCER.MANUAL_REQUESTED;\n  payload: { providerId: string; skipOfflineCheck: boolean };\n}\n\nexport interface IBalancerManualSucceeded {\n  type: BALANCER.MANUAL_SUCCEEDED;\n  payload: { providerId: string };\n}\n\nexport interface IBalancerManualFailed {\n  type: BALANCER.MANUAL_FAILED;\n  payload: { error: string };\n}\n\nexport type BalancerAction =\n  | IBalancerInit\n  | IBalancerOffline\n  | IBalancerOnline\n  | IBalancerFlush\n  | IBalancerSetProviderCallRetryThreshold\n  | IBalancerAuto\n  | IBalancerManualRequested\n  | IBalancerManualSucceeded\n  | IBalancerManualFailed\n  | IBalancerNetworkSwitchRequested\n  | IBalancerNetworkSwitchSucceeded;\n","import { idGeneratorFactory } from '@src/utils/idGenerator';\nimport {\n  BALANCER,\n  IBalancerAuto,\n  IBalancerFlush,\n  IBalancerInit,\n  IBalancerManualFailed,\n  IBalancerManualRequested,\n  IBalancerManualSucceeded,\n  IBalancerNetworkSwitchRequested,\n  IBalancerNetworkSwitchSucceeded,\n  IBalancerOffline,\n  IBalancerOnline,\n  IBalancerQueueTimeout,\n  IBalancerSetProviderCallRetryThreshold,\n} from './types';\n\nexport const balancerFlush = (): IBalancerFlush => ({\n  type: BALANCER.FLUSH,\n});\n\nconst networkIdGenerator = idGeneratorFactory();\nexport const balancerNetworkSwitchRequested = (\n  payload: IBalancerNetworkSwitchRequested['payload'],\n): IBalancerNetworkSwitchRequested => ({\n  payload,\n  type: BALANCER.NETWORK_SWTICH_REQUESTED,\n  meta: { id: networkIdGenerator() },\n});\n\nexport const balancerNetworkSwitchSucceeded = (\n  payload: IBalancerNetworkSwitchSucceeded['payload'],\n  id: number,\n): IBalancerNetworkSwitchSucceeded => ({\n  type: BALANCER.NETWORK_SWITCH_SUCCEEDED,\n  payload,\n  meta: { id },\n});\n\nexport const balancerSetProviderCallRetryThreshold = (\n  payload: IBalancerSetProviderCallRetryThreshold['payload'],\n): IBalancerSetProviderCallRetryThreshold => ({\n  type: BALANCER.SET_PROVIDER_CALL_RETRY_THRESHOLD,\n  payload,\n});\n\nexport const balancerInit = (\n  payload: IBalancerInit['payload'],\n): IBalancerInit => ({\n  type: BALANCER.INIT,\n  payload,\n  meta: { id: networkIdGenerator() },\n});\n\nexport const setOffline = (): IBalancerOffline => ({\n  type: BALANCER.OFFLINE,\n});\n\nexport const setOnline = (): IBalancerOnline => ({\n  type: BALANCER.ONLINE,\n});\n\nexport const setAuto = (): IBalancerAuto => ({ type: BALANCER.AUTO });\n\nexport const setManualRequested = (\n  payload: IBalancerManualRequested['payload'],\n): IBalancerManualRequested => ({\n  type: BALANCER.MANUAL_REQUESTED,\n  payload,\n});\n\nexport const setManualSucceeded = (\n  payload: IBalancerManualSucceeded['payload'],\n): IBalancerManualSucceeded => ({\n  type: BALANCER.MANUAL_SUCCEEDED,\n  payload,\n});\n\nexport const setManualFailed = (\n  payload: IBalancerManualFailed['payload'],\n): IBalancerManualFailed => ({\n  type: BALANCER.MANUAL_FAILED,\n  payload,\n});\n\nexport const balancerQueueTimeout = (): IBalancerQueueTimeout => ({\n  type: BALANCER.QUEUE_TIMEOUT,\n});\n","import { IBalancerManualSucceeded } from '@src/ducks/providerBalancer/balancerConfig';\nimport { Reducer } from 'redux';\nimport {\n  BALANCER,\n  BalancerAction,\n  IBalancerAuto,\n  IBalancerConfigState,\n} from './types';\n\nconst INITIAL_STATE: IBalancerConfigState = {\n  manual: false,\n  offline: true,\n  network: 'ETH',\n  providerCallRetryThreshold: 3,\n  networkSwitchPending: false,\n  queueTimeout: 5000,\n};\n\nconst handleBalancerAuto: Reducer<IBalancerConfigState> = (\n  state: IBalancerConfigState,\n  _: IBalancerAuto,\n) => ({\n  ...state,\n  manual: false,\n});\n\nconst handleBalancerManual: Reducer<IBalancerConfigState> = (\n  state: IBalancerConfigState,\n  { payload }: IBalancerManualSucceeded,\n) => ({\n  ...state,\n  manual: payload.providerId,\n});\n\nexport const balancerConfigReducer: Reducer<IBalancerConfigState> = (\n  state: IBalancerConfigState = INITIAL_STATE,\n  action: BalancerAction,\n): IBalancerConfigState => {\n  switch (action.type) {\n    case BALANCER.INIT:\n      return { ...state, ...action.payload };\n    case BALANCER.AUTO:\n      return handleBalancerAuto(state, action);\n    case BALANCER.MANUAL_SUCCEEDED:\n      return handleBalancerManual(state, action);\n    case BALANCER.OFFLINE:\n      return { ...state, offline: true };\n    case BALANCER.ONLINE:\n      return { ...state, offline: false };\n    case BALANCER.NETWORK_SWITCH_SUCCEEDED:\n      return {\n        ...state,\n        network: action.payload.network,\n        networkSwitchPending: false,\n      };\n    case BALANCER.NETWORK_SWTICH_REQUESTED:\n      return { ...state, networkSwitchPending: true };\n    case BALANCER.SET_PROVIDER_CALL_RETRY_THRESHOLD:\n      return {\n        ...state,\n        providerCallRetryThreshold: action.payload.threshold,\n      };\n    default:\n      return state;\n  }\n};\n","class Logger {\n  private shouldLog: boolean = false;\n\n  public enableLogging() {\n    this.shouldLog = true;\n  }\n  public log(...args: any[]) {\n    if (!this.shouldLog) {\n      return;\n    }\n    console.log(...args);\n  }\n}\n\nexport const logger = new Logger();\n","import { logger } from '@src/utils/logging';\nimport { Store } from 'redux';\n\nclass StoreManager {\n  private store: Store<any> | undefined;\n  private root: string | undefined;\n\n  public setRoot(r: string) {\n    logger.log(`Setting root to: ${r}`);\n    this.root = r;\n  }\n\n  public getRoot() {\n    return this.root;\n  }\n\n  public setStore(s: Store<any>) {\n    this.store = s;\n  }\n\n  public getStore() {\n    if (!this.store) {\n      throw Error('no store');\n    }\n    return this.store;\n  }\n}\n\nexport const storeManager = new StoreManager();\n","import { storeManager } from '@src/ducks/store';\nimport { RootState } from '@src/types';\n\nexport const getRootState = (s: any): RootState => {\n  const customRoot = storeManager.getRoot();\n  return customRoot ? s[customRoot] : s;\n};\n","import { getRootState } from '@src/ducks/rootState';\nimport { RootState } from '@src/types';\n\nexport const getProviderBalancer = (state: RootState) =>\n  getRootState(state).providerBalancer;\n","import { IProviderCallTimeout } from '@src/ducks/providerBalancer/providerCalls';\nimport { getProviderBalancer } from '@src/ducks/providerBalancer/selectors';\nimport { RootState } from '@src/types';\n\nexport const getBalancerConfig = (state: RootState) =>\n  getProviderBalancer(state).balancerConfig;\n\nexport const getQueueTimeout = (state: RootState) =>\n  getBalancerConfig(state).queueTimeout;\n\nexport const getManualMode = (state: RootState) =>\n  getBalancerConfig(state).manual;\n\nexport const isOffline = (state: RootState) => getBalancerConfig(state).offline;\n\nexport const getNetwork = (state: RootState) =>\n  getBalancerConfig(state).network;\n\nexport const getProviderCallRetryThreshold = (state: RootState) =>\n  getBalancerConfig(state).providerCallRetryThreshold;\n\nexport const isSwitchingNetworks = (state: RootState) =>\n  getBalancerConfig(state).networkSwitchPending;\n\nexport const callMeetsBalancerRetryThreshold = (\n  state: RootState,\n  { payload: { providerCall } }: IProviderCallTimeout,\n) => {\n  const providerCallRetryThreshold = getProviderCallRetryThreshold(state);\n\n  // checks the current call to see if it has failed more than the configured number\n  return providerCall.numOfRetries >= providerCallRetryThreshold;\n};\n","import { AllProviderMethods, StrIdx } from '@src/types';\n\nexport type ProviderCallState =\n  | ISuccessfulProviderCall\n  | IPendingProviderCall\n  | IFailedProviderCall;\n\nexport type ProviderCallsState = StrIdx<ProviderCallState>;\n\nexport enum PROVIDER_CALL {\n  REQUESTED = 'PROVIDER_CALL_REQUESTED',\n  TIMEOUT = 'PROVIDER_CALL_TIMEOUT',\n  SUCCEEDED = 'PROVIDER_CALL_SUCCEEDED',\n  FAILED = 'PROVIDER_CALL_FAILED',\n  FLUSHED = 'PROVIDER_CALL_FLUSHED',\n}\n\nexport interface IProviderCall {\n  callId: number;\n  rpcMethod: AllProviderMethods;\n  rpcArgs: string[];\n  numOfRetries: number;\n  minPriorityProviderList: string[];\n  providerWhiteList?: string[];\n  providerId?: string;\n}\n\nexport type ProviderCallWithPid = IProviderCall & { providerId: string };\n\nexport interface ISuccessfulProviderCall extends IProviderCall {\n  result: string;\n  error: null;\n  pending: false;\n}\n\nexport interface IFailedProviderCall extends ProviderCallWithPid {\n  result: null;\n  error: string;\n  pending: false;\n}\n\nexport interface IFlushedProviderCall extends IProviderCall {\n  result: null;\n  error: string;\n  pending: false;\n}\n\nexport interface IPendingProviderCall extends IProviderCall {\n  result: null;\n  error: null;\n  pending: true;\n}\n\nexport interface IProviderCallRequested {\n  type: PROVIDER_CALL.REQUESTED;\n  payload: IProviderCall;\n}\n\nexport interface IProviderCallTimeout {\n  type: PROVIDER_CALL.TIMEOUT;\n  payload: { error: Error; providerCall: ProviderCallWithPid };\n}\n\nexport interface IProviderCallFailed {\n  type: PROVIDER_CALL.FAILED;\n  payload: { error: string; providerCall: ProviderCallWithPid };\n}\n\nexport interface IProviderCallFlushed {\n  type: PROVIDER_CALL.FLUSHED;\n  payload: { error: string; providerCall: IProviderCall };\n}\n\nexport interface IProviderCallSucceeded {\n  type: PROVIDER_CALL.SUCCEEDED;\n  payload: { result: string; providerCall: ProviderCallWithPid };\n}\n\nexport type ProviderCallAction =\n  | IProviderCallRequested\n  | IProviderCallTimeout\n  | IProviderCallFailed\n  | IProviderCallSucceeded\n  | IProviderCallFlushed;\n","import {\n  IProviderCallFailed,\n  IProviderCallFlushed,\n  IProviderCallRequested,\n  IProviderCallSucceeded,\n  IProviderCallTimeout,\n  PROVIDER_CALL,\n} from './types';\n\nexport const providerCallRequested = (\n  payload: IProviderCallRequested['payload'],\n): IProviderCallRequested => ({\n  type: PROVIDER_CALL.REQUESTED,\n  payload,\n});\n\nexport const providerCallTimeout = (\n  payload: IProviderCallTimeout['payload'],\n): IProviderCallTimeout => ({\n  type: PROVIDER_CALL.TIMEOUT,\n  payload,\n});\n\nexport const providerCallFailed = (\n  payload: IProviderCallFailed['payload'],\n): IProviderCallFailed => ({\n  type: PROVIDER_CALL.FAILED,\n  payload,\n});\n\nexport const providerCallFlushed = (\n  payload: IProviderCallFlushed['payload'],\n): IProviderCallFlushed => ({ type: PROVIDER_CALL.FLUSHED, payload });\n\nexport const providerCallSucceeded = (\n  payload: IProviderCallSucceeded['payload'],\n): IProviderCallSucceeded => ({\n  type: PROVIDER_CALL.SUCCEEDED,\n  payload,\n});\n","import { IPendingProviderCall } from '@src/ducks/providerBalancer/providerCalls';\nimport { getProviderBalancer } from '@src/ducks/providerBalancer/selectors';\nimport { RootState } from '@src/types';\n\nexport const getProviderCalls = (state: RootState) =>\n  getProviderBalancer(state).providerCalls;\n\nexport const getProviderCallById = (state: RootState, id: number) =>\n  getProviderCalls(state)[id];\n\nexport const isStaleCall = (state: RootState, callId: number) => {\n  const call = getProviderCallById(state, callId);\n  return !call || !call.pending;\n};\n\nexport const getPendingProviderCallsByProviderId = (\n  state: RootState,\n  providerId: string,\n) => {\n  const pendingCalls = getAllPendingCalls(state);\n  const pendingCallsByProviderId = pendingCalls.filter(\n    providerCall =>\n      providerCall.providerId && providerCall.providerId === providerId,\n  );\n  return pendingCallsByProviderId.length;\n};\n\nexport const getAllPendingCalls = (\n  state: RootState,\n): IPendingProviderCall[] => {\n  const providerCalls = getProviderCalls(state);\n  const providerCallsArr = Object.values(providerCalls);\n  const pendingCalls: IPendingProviderCall[] = providerCallsArr.filter(\n    (providerCall): providerCall is IPendingProviderCall => {\n      if (providerCall.pending) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n  );\n  return pendingCalls;\n};\n","import { ProviderCallWithPid } from '@src/ducks/providerBalancer/providerCalls';\nimport { Task } from 'redux-saga';\nimport { IProviderCall } from '../providerCalls';\n\nexport interface IWorker {\n  task: Task;\n  assignedProvider: string;\n  currentPayload: IProviderCall | null;\n}\n\nexport interface IWorkerState {\n  [workerId: string]: Readonly<IWorker>;\n}\n\nexport enum WORKER {\n  PROCESSING = 'WORKER_PROCESSING',\n  SPAWNED = 'WORKER_SPAWNED',\n  KILLED = 'WORKER_KILLED',\n}\n\nexport interface IWorkerSpawned {\n  type: WORKER.SPAWNED;\n  payload: {\n    providerId: string;\n    workerId: string;\n    task: Task;\n  };\n}\n\nexport interface IWorkerProcessing {\n  type: WORKER.PROCESSING;\n  payload: {\n    workerId: string;\n    currentPayload: ProviderCallWithPid;\n  };\n}\n\nexport interface IWorkerKilled {\n  type: WORKER.KILLED;\n  payload: {\n    providerId: string;\n    workerId: string;\n    error: Error;\n  };\n}\n\nexport type WorkerAction = IWorkerSpawned | IWorkerProcessing | IWorkerKilled;\n","import {\n  IWorkerKilled,\n  IWorkerProcessing,\n  IWorkerSpawned,\n  WORKER,\n} from './types';\n\nexport const workerSpawned = (\n  payload: IWorkerSpawned['payload'],\n): IWorkerSpawned => ({\n  type: WORKER.SPAWNED,\n  payload,\n});\n\nexport const workerProcessing = (\n  payload: IWorkerProcessing['payload'],\n): IWorkerProcessing => ({\n  type: WORKER.PROCESSING,\n  payload,\n});\n\nexport const workerKilled = (\n  payload: IWorkerKilled['payload'],\n): IWorkerKilled => ({\n  type: WORKER.KILLED,\n  payload,\n});\n","import { getProviderBalancer } from '@src/ducks/providerBalancer/selectors';\nimport { RootState } from '@src/types';\n\nexport const getWorkers = (state: RootState) =>\n  getProviderBalancer(state).workers;\n\nexport const getWorkerById = (state: RootState, id: string) =>\n  getWorkers(state)[id];\n","import { IWorker } from '@src/ducks/providerBalancer/workers';\nimport { StrIdx } from '@src/types';\n\nexport interface IProviderStats {\n  currWorkersById: string[];\n  isOffline: boolean;\n  requestFailures: number;\n  avgResponseTime: number;\n}\n\nexport interface IProviderStatsState {\n  [providerId: string]: Readonly<IProviderStats>;\n}\n\nexport enum PROVIDER_STATS {\n  ONLINE = 'PROVIDER_STATS_ONLINE',\n  OFFLINE = 'PROVIDER_STATS_OFFLINE',\n  ADDED = 'PROVIDER_STATS_ADDED',\n  REMOVED = 'PROVIDER_STATS_REMOVED',\n}\n\nexport interface IProviderStatsOnline {\n  type: PROVIDER_STATS.ONLINE;\n  payload: {\n    providerId: string;\n  };\n}\n\nexport interface IProviderStatsOffline {\n  type: PROVIDER_STATS.OFFLINE;\n  payload: {\n    providerId: string;\n  };\n}\n\nexport interface IProviderStatsAdded {\n  type: PROVIDER_STATS.ADDED;\n  payload: {\n    providerId: string;\n    stats: IProviderStats;\n    workers: StrIdx<IWorker>;\n  };\n}\n\nexport type ProcessedProvider = IProviderStatsAdded['payload'];\n\nexport interface IProviderStatsRemoved {\n  type: PROVIDER_STATS.REMOVED;\n  payload: { providerId: string };\n}\n\nexport type ProviderStatsAction =\n  | IProviderStatsOnline\n  | IProviderStatsOffline\n  | IProviderStatsAdded\n  | IProviderStatsRemoved;\n","import {\n  IProviderStatsAdded,\n  IProviderStatsOffline,\n  IProviderStatsOnline,\n  IProviderStatsRemoved,\n  PROVIDER_STATS,\n} from './types';\n\nexport const providerOnline = (\n  payload: IProviderStatsOnline['payload'],\n): IProviderStatsOnline => ({\n  type: PROVIDER_STATS.ONLINE,\n  payload,\n});\n\nexport const providerOffline = (\n  payload: IProviderStatsOffline['payload'],\n): IProviderStatsOffline => ({\n  type: PROVIDER_STATS.OFFLINE,\n  payload,\n});\n\nexport const providerAdded = (\n  payload: IProviderStatsAdded['payload'],\n): IProviderStatsAdded => ({\n  type: PROVIDER_STATS.ADDED,\n  payload,\n});\n\nexport const providerRemoved = (\n  payload: IProviderStatsRemoved['payload'],\n): IProviderStatsRemoved => ({\n  type: PROVIDER_STATS.REMOVED,\n  payload,\n});\n","import {\n  IProviderStats,\n  IProviderStatsState,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { getProviderBalancer } from '@src/ducks/providerBalancer/selectors';\nimport { RootState } from '@src/types';\n\nexport const getProviderStats = (state: RootState) =>\n  getProviderBalancer(state).providerStats;\n\nexport const getProviderStatsById = (\n  state: RootState,\n  id: string,\n): Readonly<IProviderStats> | null => getProviderStats(state)[id];\n\nexport type OnlineProviders = {\n  [providerId in keyof IProviderStatsState]: IProviderStatsState[providerId] & {\n    isOffline: false;\n  }\n};\n\n/**\n * @description an available provider === it being online\n * @param state\n */\nexport const getOnlineProviders = (state: RootState): OnlineProviders => {\n  const providers = getProviderStats(state);\n  const initialState: OnlineProviders = {};\n\n  const isOnline = (\n    provider: IProviderStatsState[string],\n  ): provider is OnlineProviders[string] => !provider.isOffline;\n\n  return Object.entries(providers).reduce(\n    (accu, [curProviderId, curProvider]) => {\n      if (isOnline(curProvider)) {\n        return { ...accu, [curProviderId]: curProvider };\n      }\n      return accu;\n    },\n    initialState,\n  );\n};\n","import {\n  BALANCER,\n  BalancerAction,\n  IBalancerFlush,\n  IBalancerNetworkSwitchSucceeded,\n} from '../balancerConfig/types';\nimport {\n  IProviderCallTimeout,\n  PROVIDER_CALL,\n  ProviderCallAction,\n} from '../providerCalls/types';\nimport {\n  IWorkerKilled,\n  IWorkerSpawned,\n  WORKER,\n  WorkerAction,\n} from '../workers/types';\nimport {\n  IProviderStatsAdded,\n  IProviderStatsOffline,\n  IProviderStatsOnline,\n  IProviderStatsRemoved,\n  IProviderStatsState,\n  PROVIDER_STATS,\n  ProviderStatsAction,\n} from './types';\n\ntype NReducer<T> = (\n  state: IProviderStatsState,\n  action: T,\n) => IProviderStatsState;\n\nconst INITIAL_STATE: IProviderStatsState = {};\n\nconst handleNetworkSwitch: NReducer<IBalancerNetworkSwitchSucceeded> = (\n  _,\n  { payload: { providerStats } },\n) => {\n  for (const [providerId, provider] of Object.entries(providerStats)) {\n    if (provider.avgResponseTime < 0) {\n      throw Error(`Provider ${providerId} has a response time of below 0`);\n    }\n    if (provider.requestFailures !== 0) {\n      throw Error(`Provider ${providerId} has non-zero request failures`);\n    }\n  }\n\n  return providerStats;\n};\n\nconst handleWorkerKilled: NReducer<IWorkerKilled> = (\n  state,\n  { payload: { providerId, workerId } },\n) => {\n  const providerToChange = state[providerId];\n  if (!providerToChange) {\n    throw Error(`Provider ${providerId} does not exist`);\n  }\n\n  if (!providerToChange.currWorkersById.includes(workerId)) {\n    throw Error(`Worker ${workerId} does not exist`);\n  }\n\n  const nextProviderProviderStatsState = {\n    ...providerToChange,\n    currWorkersById: providerToChange.currWorkersById.filter(\n      id => id !== workerId,\n    ),\n  };\n  return { ...state, [providerId]: nextProviderProviderStatsState };\n};\n\nconst handleWorkerSpawned: NReducer<IWorkerSpawned> = (\n  state,\n  { payload: { providerId, workerId } },\n) => {\n  // check for existence of provider\n  const providerToChange = state[providerId];\n  if (!providerToChange) {\n    throw Error(`Provider ${providerId} does not exist`);\n  }\n\n  // check for duplicates\n  if (providerToChange.currWorkersById.includes(workerId)) {\n    throw Error(`Worker ${workerId} already exists`);\n  }\n\n  const nextProviderProviderStatsState = {\n    ...providerToChange,\n    currWorkersById: [...providerToChange.currWorkersById, workerId],\n  };\n  return { ...state, [providerId]: nextProviderProviderStatsState };\n};\n\nconst handleProviderOnline: NReducer<IProviderStatsOnline> = (\n  state,\n  { payload: { providerId } },\n) => {\n  // check for existence of provider\n  const providerToChange = state[providerId];\n  if (!providerToChange) {\n    throw Error(`Provider ${providerId} does not exist`);\n  }\n\n  return {\n    ...state,\n    [providerId]: {\n      ...providerToChange,\n      isOffline: false,\n    },\n  };\n};\n\nconst handleProviderOffline: NReducer<IProviderStatsOffline> = (\n  state,\n  { payload: { providerId } },\n) => {\n  // check for existence of provider\n  const providerToChange = state[providerId];\n  if (!providerToChange) {\n    // done for initialization phase\n    return state;\n  }\n\n  return {\n    ...state,\n    [providerId]: {\n      ...providerToChange,\n      isOffline: true,\n      requestFailures: 0,\n    },\n  };\n};\n\nconst handleProviderAdded: NReducer<IProviderStatsAdded> = (\n  state: IProviderStatsState,\n  { payload: { providerId, stats } },\n) => {\n  if (state[providerId]) {\n    throw Error(`Provider ${providerId} already exists`);\n  }\n\n  return { ...state, [providerId]: stats };\n};\n\nconst handleProviderRemoved: NReducer<IProviderStatsRemoved> = (\n  state,\n  { payload },\n) => {\n  if (!state[payload.providerId]) {\n    throw Error(`Provider ${payload.providerId} does not exist`);\n  }\n  const stateCopy = { ...state };\n  Reflect.deleteProperty(stateCopy, payload.providerId);\n  return stateCopy;\n};\n\nconst handleProviderCallTimeout: NReducer<IProviderCallTimeout> = (\n  state: IProviderStatsState,\n  { payload: { providerCall: { providerId } } }: IProviderCallTimeout,\n) => {\n  // check for existence of provider\n  const providerToChange = state[providerId];\n  if (!providerToChange) {\n    throw Error(`Provider ${providerId} does not exist`);\n  }\n\n  return {\n    ...state,\n    [providerId]: {\n      ...providerToChange,\n      requestFailures: providerToChange.requestFailures + 1,\n    },\n  };\n};\n\nconst handleBalancerFlush: NReducer<IBalancerFlush> = state =>\n  Object.entries(state).reduce<IProviderStatsState>(\n    (obj, [providerId, stats]) => ({\n      ...obj,\n      [providerId]: { ...stats, requestFailures: 0 },\n    }),\n    {},\n  );\n\nexport const providerStatsReducer: NReducer<\n  ProviderStatsAction | WorkerAction | ProviderCallAction | BalancerAction\n> = (state = INITIAL_STATE, action): IProviderStatsState => {\n  switch (action.type) {\n    case WORKER.KILLED:\n      return handleWorkerKilled(state, action);\n    case WORKER.SPAWNED:\n      return handleWorkerSpawned(state, action);\n    case PROVIDER_STATS.ONLINE:\n      return handleProviderOnline(state, action);\n    case PROVIDER_STATS.OFFLINE:\n      return handleProviderOffline(state, action);\n    case PROVIDER_STATS.ADDED:\n      return handleProviderAdded(state, action);\n    case PROVIDER_STATS.REMOVED:\n      return handleProviderRemoved(state, action);\n    case PROVIDER_CALL.TIMEOUT:\n      return handleProviderCallTimeout(state, action);\n    case BALANCER.FLUSH:\n      return handleBalancerFlush(state, action);\n    case BALANCER.NETWORK_SWITCH_SUCCEEDED:\n      return handleNetworkSwitch(state, action);\n    default:\n      return state;\n  }\n};\n","import {\n  IProviderStatsAdded,\n  PROVIDER_STATS,\n  ProviderStatsAction,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { Reducer } from 'redux';\nimport {\n  BALANCER,\n  BalancerAction,\n  IBalancerNetworkSwitchSucceeded,\n} from '../balancerConfig/types';\nimport {\n  IProviderCallSucceeded,\n  IProviderCallTimeout,\n  PROVIDER_CALL,\n  ProviderCallAction,\n} from '../providerCalls/types';\nimport {\n  IWorkerKilled,\n  IWorkerProcessing,\n  IWorkerSpawned,\n  WORKER,\n  WorkerAction,\n} from '../workers/types';\nimport { IWorkerState } from './types';\n\ntype WReducer = Reducer<IWorkerState>;\nconst INITIAL_STATE: IWorkerState = {};\n\nconst handleNetworkSwitch: WReducer = (\n  _: IWorkerState,\n  { payload }: IBalancerNetworkSwitchSucceeded,\n) => {\n  // validation\n  for (const [workerId, worker] of Object.entries(payload.workers)) {\n    if (!worker.task) {\n      throw Error(`Worker ${workerId} has no saga task assigned`);\n    }\n    if (worker.currentPayload) {\n      throw Error(`Worker ${workerId} should not have an existing payload`);\n    }\n  }\n\n  return payload.workers;\n};\n\nconst handleWorkerKilled: WReducer = (\n  state: IWorkerState,\n  { payload }: IWorkerKilled,\n) => {\n  if (!state[payload.workerId]) {\n    throw Error(`Worker ${payload.workerId} does not exist`);\n  }\n\n  const stateCopy = { ...state };\n  Reflect.deleteProperty(stateCopy, payload.workerId);\n  return stateCopy;\n};\n\nconst handleWorkerProcessing: WReducer = (\n  state: IWorkerState,\n  { payload: { currentPayload, workerId } }: IWorkerProcessing,\n) => {\n  if (!state[workerId]) {\n    throw Error(`Worker ${workerId} does not exist`);\n  }\n\n  if (state[workerId].currentPayload) {\n    throw Error(`Worker ${workerId} is already processing a payload`);\n  }\n\n  return {\n    ...state,\n    [workerId]: { ...state[workerId], currentPayload },\n  };\n};\n\nconst handleWorkerSpawned: WReducer = (\n  state: IWorkerState,\n  { payload }: IWorkerSpawned,\n) => {\n  if (state[payload.workerId]) {\n    throw Error(`Worker ${payload.workerId} already exists`);\n  }\n\n  return {\n    ...state,\n    [payload.workerId]: {\n      assignedProvider: payload.providerId,\n      task: payload.task,\n      currentPayload: null,\n    },\n  };\n};\n\nconst handleProviderAdded: WReducer = (\n  state,\n  { payload }: IProviderStatsAdded,\n) => {\n  const stateCopy = { ...state };\n  for (const [workerId, worker] of Object.entries(payload.workers)) {\n    if (stateCopy[workerId]) {\n      throw Error(`Worker ${workerId} already exists`);\n    }\n\n    stateCopy[workerId] = {\n      assignedProvider: worker.assignedProvider,\n      task: worker.task,\n      currentPayload: null,\n    };\n  }\n  return stateCopy;\n};\n\nconst handleProviderCallSucceeded: WReducer = (\n  state: IWorkerState,\n  { payload }: IProviderCallSucceeded,\n) => {\n  const { providerCall: { callId } } = payload;\n  const worker = Object.entries(state).find(\n    ([_, { currentPayload }]) =>\n      !!(currentPayload && currentPayload.callId === callId),\n  );\n\n  if (!worker) {\n    throw Error(`Worker not found for a successful request`);\n  }\n\n  const [workerId, workerInst] = worker;\n\n  return { ...state, [workerId]: { ...workerInst, currentPayload: null } };\n};\n\nconst handleProviderCallTimeout: WReducer = (\n  state: IWorkerState,\n  { payload }: IProviderCallTimeout,\n) => {\n  const { providerCall } = payload;\n  const worker = Object.entries(state).find(\n    ([_, { currentPayload }]) =>\n      !!(currentPayload && currentPayload.callId === providerCall.callId),\n  );\n\n  if (!worker) {\n    throw Error(`Worker not found for a timed out request`);\n  }\n\n  const [workerId, workerInst] = worker;\n\n  return { ...state, [workerId]: { ...workerInst, currentPayload: null } };\n};\n\nexport const workerReducer: WReducer = (\n  state: IWorkerState = INITIAL_STATE,\n  action:\n    | WorkerAction\n    | ProviderCallAction\n    | BalancerAction\n    | ProviderStatsAction,\n): IWorkerState => {\n  switch (action.type) {\n    case WORKER.SPAWNED:\n      return handleWorkerSpawned(state, action);\n    case WORKER.PROCESSING:\n      return handleWorkerProcessing(state, action);\n    case WORKER.KILLED:\n      return handleWorkerKilled(state, action);\n\n    case BALANCER.NETWORK_SWITCH_SUCCEEDED:\n      return handleNetworkSwitch(state, action);\n\n    case PROVIDER_CALL.SUCCEEDED:\n      return handleProviderCallSucceeded(state, action);\n    case PROVIDER_CALL.TIMEOUT:\n      return handleProviderCallTimeout(state, action);\n\n    case PROVIDER_STATS.ADDED:\n      return handleProviderAdded(state, action);\n    default:\n      return state;\n  }\n};\n","import { IProviderCallFlushed } from '@src/ducks/providerBalancer/providerCalls';\nimport {\n  IWorkerProcessing,\n  WORKER,\n  WorkerAction,\n} from '@src/ducks/providerBalancer/workers';\nimport {\n  IProviderCallFailed,\n  IProviderCallRequested,\n  IProviderCallSucceeded,\n  PROVIDER_CALL,\n  ProviderCallAction,\n  ProviderCallsState,\n} from './types';\n\nconst handleProviderCallSucceeded = (\n  state: ProviderCallsState,\n  { payload }: IProviderCallSucceeded,\n): ProviderCallsState => {\n  const call = state[payload.providerCall.callId];\n  if (!call || !call.pending) {\n    throw Error(`Pending provider call not found ${call ? call.callId : ''}`);\n  }\n\n  return {\n    ...state,\n    [payload.providerCall.callId]: {\n      ...payload.providerCall,\n      result: payload.result,\n      error: null,\n      pending: false,\n    },\n  };\n};\n\nconst handleProviderCallFailed = (\n  state: ProviderCallsState,\n  { payload }: IProviderCallFailed,\n): ProviderCallsState => {\n  const call = state[payload.providerCall.callId];\n  if (!call || !call.pending) {\n    throw Error('Pending provider call not found');\n  }\n\n  return {\n    ...state,\n    [payload.providerCall.callId]: {\n      error: payload.error,\n      ...payload.providerCall,\n      result: null,\n      pending: false,\n    },\n  };\n};\n\nconst handleProviderCallFlushed = (\n  state: ProviderCallsState,\n  { payload }: IProviderCallFlushed,\n): ProviderCallsState => {\n  const call = state[payload.providerCall.callId];\n\n  if (!call || !call.pending) {\n    console.error('Pending provider call not found when flushing');\n  }\n\n  return {\n    ...state,\n    [payload.providerCall.callId]: {\n      error: payload.error,\n      ...payload.providerCall,\n      result: null,\n      pending: false,\n    },\n  };\n};\n\nconst handleProviderCallPending = (\n  state: ProviderCallsState,\n  { payload }: IProviderCallRequested,\n): ProviderCallsState => {\n  const call = state[payload.callId];\n\n  // a duplicate check that makes sure the incoming call is either new or a retry call\n  if (call && call.numOfRetries === payload.numOfRetries) {\n    throw Error('Provider call already exists');\n  }\n  return {\n    ...state,\n    [payload.callId]: { ...payload, error: null, result: null, pending: true },\n  };\n};\n\nconst handleWorkerProcessing = (\n  state: ProviderCallsState,\n  { payload: { currentPayload } }: IWorkerProcessing,\n) => {\n  const prevPayload = state[currentPayload.callId];\n  if (!prevPayload || !prevPayload.pending) {\n    throw Error('Pending provider call not found');\n  }\n\n  const nextPayload = { ...prevPayload, providerId: currentPayload.providerId };\n\n  return {\n    ...state,\n    [currentPayload.callId]: nextPayload,\n  };\n};\n\nconst INITIAL_STATE: ProviderCallsState = {};\n\nexport const providerCallsReducer = (\n  state: ProviderCallsState = INITIAL_STATE,\n  action: ProviderCallAction | WorkerAction,\n) => {\n  switch (action.type) {\n    case PROVIDER_CALL.REQUESTED:\n      return handleProviderCallPending(state, action);\n    case WORKER.PROCESSING:\n      return handleWorkerProcessing(state, action);\n    case PROVIDER_CALL.SUCCEEDED:\n      return handleProviderCallSucceeded(state, action);\n    case PROVIDER_CALL.FAILED:\n      return handleProviderCallFailed(state, action);\n    case PROVIDER_CALL.FLUSHED:\n      return handleProviderCallFlushed(state, action);\n    default:\n      return state;\n  }\n};\n","export enum SUBSCRIBE {\n  ACTION = 'SUBSCRIBE_TO_ACTION',\n}\n\nexport interface ISubscribe {\n  type: SUBSCRIBE.ACTION;\n  payload: {\n    trigger: any;\n    callback(resultingAction: any): void;\n  };\n}\n\nexport type SubscribeAction = ISubscribe;\n","import { ISubscribe, SUBSCRIBE } from './types';\n\nexport function subscribeToAction(payload: ISubscribe['payload']): ISubscribe {\n  return { type: SUBSCRIBE.ACTION, payload };\n}\n","import {\n  BALANCER,\n  IBalancerManualFailed,\n  IBalancerManualSucceeded,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { PROVIDER_CALL } from '@src/ducks/providerBalancer/providerCalls';\nimport { subscribeToAction } from '@src/ducks/subscribe';\nimport { AllActions } from '@src/ducks/types';\nimport { Reject, Resolve, RootState } from '@src/types';\nimport { Dispatch } from 'redux';\n\nexport const triggerOnMatchingCallId = (\n  callId: number,\n  includeTimeouts: boolean,\n) => (action: AllActions) => {\n  // check if the action is a provider failed or succeeded call\n  if (\n    action.type === PROVIDER_CALL.SUCCEEDED ||\n    action.type === PROVIDER_CALL.FAILED ||\n    action.type === PROVIDER_CALL.FLUSHED ||\n    (includeTimeouts && action.type === PROVIDER_CALL.TIMEOUT)\n  ) {\n    // make sure its the same call\n    return action.payload.providerCall.callId === callId;\n  }\n};\n\nexport function waitForNetworkSwitch(\n  dispatch: Dispatch<RootState>,\n  id: number,\n) {\n  return new Promise(res =>\n    dispatch(\n      subscribeToAction({\n        trigger: (action: AllActions) => {\n          if (action.type === BALANCER.NETWORK_SWITCH_SUCCEEDED) {\n            return action.meta.id === id;\n          }\n          return false;\n        },\n        callback: res,\n      }),\n    ),\n  );\n}\n\nexport function waitForManualMode(\n  dispatch: Dispatch<RootState>,\n): Promise<string> {\n  function triggerOnSuccessOrFail(action: AllActions) {\n    return (\n      action.type === BALANCER.MANUAL_SUCCEEDED ||\n      action.type === BALANCER.MANUAL_FAILED\n    );\n  }\n\n  const returnSuccessOrFail = (resolve: Resolve, reject: Reject) => (\n    action: IBalancerManualFailed | IBalancerManualSucceeded,\n  ) =>\n    action.type === BALANCER.MANUAL_SUCCEEDED\n      ? resolve(action.payload.providerId)\n      : reject(Error(action.payload.error));\n\n  return new Promise((resolve, reject) =>\n    dispatch(\n      subscribeToAction({\n        trigger: triggerOnSuccessOrFail,\n        callback: returnSuccessOrFail(resolve, reject),\n      }),\n    ),\n  );\n}\n","import { AllProviderMethods, DeepPartial } from '@src/types';\n\nexport enum PROVIDER_CONFIG {\n  ADD = 'PROVIDER_CONFIG_ADD',\n  CHANGE = 'PROVIDER_CONFIG_CHANGE',\n  REMOVE = 'PROVIDER_CONFIG_REMOVE',\n}\n\nexport interface IProviderConfig {\n  /**\n   * @description The maximum number of concurrent calls to make to the provider instance using this config.\n   * This number determines how many workers to spawn to process incoming rpc requests\n   */\n  concurrency: number;\n  /**\n   * @description The threshold of failed calls before deeming a provider to be offline\n   * (which means it will no longer have rpc calls routed to it), which will then be polled until it responds.\n   * If it responds, it will be changed to an online state and continue to have applicable calls as outlined in supportedMethods routed to it\n   */\n  requestFailureThreshold: number;\n  /**\n   * @description How long to wait on an rpc call (also applies to the initial ping to determine if a provider is online) before determining that it has timed out\n   */\n  timeoutThresholdMs: number;\n  /**\n   * @description All supported rpc methods by this provider config,\n   * disable a method for a config by setting it to false, this will\n   * prevent any rpc calls set to false to be routed to the provider instance using this config\n   */\n  supportedMethods: { [rpcMethod in AllProviderMethods]: boolean };\n  /**\n   * @description The associated network name of this provider config to be used by the balancer when switching networks\n   */\n  network: string;\n}\n\nexport interface IProviderConfigState {\n  [key: string]: IProviderConfig;\n}\n\nexport interface IAddProviderConfig {\n  type: PROVIDER_CONFIG.ADD;\n  payload: { id: string; config: IProviderConfig };\n}\n\nexport interface IChangeProviderConfig {\n  type: PROVIDER_CONFIG.CHANGE;\n  payload: { id: string; config: DeepPartial<IProviderConfig> };\n}\n\nexport interface IRemoveProviderConfig {\n  type: PROVIDER_CONFIG.REMOVE;\n  payload: { id: string };\n}\n\nexport type ProviderConfigAction =\n  | IAddProviderConfig\n  | IChangeProviderConfig\n  | IRemoveProviderConfig;\n","import { Reducer } from 'redux';\nimport {\n  IAddProviderConfig,\n  IChangeProviderConfig,\n  IProviderConfigState,\n  IRemoveProviderConfig,\n  PROVIDER_CONFIG,\n  ProviderConfigAction,\n} from './types';\n\nexport const INITIAL_STATE: IProviderConfigState = {};\n\ntype PCReducer = Reducer<IProviderConfigState>;\n\nconst handleProviderConfigAdd: PCReducer = (\n  state,\n  { payload }: IAddProviderConfig,\n) => {\n  if (state[payload.id]) {\n    throw Error(`Provider config ${payload.id} already exists`);\n  }\n  return { ...state, [payload.id]: payload.config };\n};\n\nconst handleProviderConfigChange: PCReducer = (\n  state,\n  { payload }: IChangeProviderConfig,\n) => {\n  const { config, id } = payload;\n  if (!state[id]) {\n    throw Error(`Provider config ${id} does not exist`);\n  }\n\n  return {\n    ...state,\n    [id]: {\n      ...state[id],\n      ...config,\n      supportedMethods: {\n        ...state[id].supportedMethods,\n        ...config.supportedMethods,\n      },\n    },\n  };\n};\n\nconst handleProviderConfigRemove: PCReducer = (\n  state,\n  { payload }: IRemoveProviderConfig,\n) => {\n  if (!state[payload.id]) {\n    throw Error(`Provider config ${payload.id} does not exist`);\n  }\n\n  const stateCopy = { ...state };\n  Reflect.deleteProperty(stateCopy, payload.id);\n  return stateCopy;\n};\n\nexport const providerConfigs = (\n  state: IProviderConfigState = INITIAL_STATE,\n  action: ProviderConfigAction,\n): IProviderConfigState => {\n  switch (action.type) {\n    case PROVIDER_CONFIG.ADD:\n      return handleProviderConfigAdd(state, action);\n    case PROVIDER_CONFIG.CHANGE:\n      return handleProviderConfigChange(state, action);\n    case PROVIDER_CONFIG.REMOVE:\n      return handleProviderConfigRemove(state, action);\n\n    default:\n      return state;\n  }\n};\n","import { IChangeProviderConfig } from '@src/ducks/providerConfigs';\nimport {\n  IAddProviderConfig,\n  IRemoveProviderConfig,\n  PROVIDER_CONFIG,\n} from './types';\n\nexport const addProviderConfig = (\n  payload: IAddProviderConfig['payload'],\n): IAddProviderConfig => ({\n  type: PROVIDER_CONFIG.ADD,\n  payload,\n});\n\nexport const removeProviderConfig = (\n  payload: IRemoveProviderConfig['payload'],\n): IRemoveProviderConfig => ({ type: PROVIDER_CONFIG.REMOVE, payload });\n\nexport const changeProviderConfig = (\n  payload: IChangeProviderConfig['payload'],\n): IChangeProviderConfig => ({ type: PROVIDER_CONFIG.CHANGE, payload });\n","import BN from 'bn.js';\n\nexport function stripHexPrefix(value: string) {\n  return value.replace('0x', '');\n}\n\ntype Wei = BN;\n\nconst handleValues = (input: string | BN | number) => {\n  if (typeof input === 'string') {\n    return input.startsWith('0x')\n      ? new BN(stripHexPrefix(input), 16)\n      : new BN(input);\n  }\n  if (typeof input === 'number') {\n    return new BN(input);\n  }\n  if (BN.isBN(input)) {\n    return input;\n  } else {\n    throw Error('unsupported value conversion');\n  }\n};\n\nconst hexToNumber = (hex: string): number => handleValues(hex).toNumber();\nconst makeBN = handleValues;\nconst Wei = handleValues;\n\nexport { Wei, handleValues, makeBN, hexToNumber };\n","import { IJsonRpcResponse } from '@src/providers/rpc/types';\nimport { Schema, Validator } from 'jsonschema';\n\n// JSONSchema Validations for Rpc responses\nconst v = new Validator();\n\nexport const schema: { [key: string]: Schema } = {\n  RpcProvider: {\n    type: 'object',\n    additionalProperties: true,\n\n    properties: {\n      jsonrpc: { type: 'string' },\n      id: { oneOf: [{ type: 'string' }, { type: 'integer' }] },\n      result: {\n        oneOf: [{ type: 'string' }, { type: 'array' }, { type: 'object' }],\n      },\n\n      status: { type: 'string', pattern: '1' }, // 1 means pass from etherscan\n      message: { type: 'string', pattern: '^OK' },\n    },\n    oneOf: [\n      {\n        additionalProperties: true,\n        type: 'object',\n        required: ['jsonrpc'],\n        properties: { jsonrpc: { type: 'string' } },\n      },\n      {\n        additionalProperties: true,\n\n        type: 'object',\n        required: ['status'],\n        properties: { status: { type: 'string' } },\n      },\n    ],\n\n    dependencies: {\n      jsonrpc: ['id', 'result'],\n      status: ['message', 'result'],\n    },\n    not: {\n      anyOf: [\n        {\n          additionalProperties: true,\n          properties: {\n            error: {\n              anyOf: [\n                { type: 'string', minLength: 1 },\n                { type: ['array', 'object', 'number', 'boolean'] },\n              ],\n            },\n          },\n          required: ['error'],\n        },\n      ],\n    },\n  },\n};\n\nfunction isValidResult(\n  response: IJsonRpcResponse,\n  schemaFormat: typeof schema.RpcProvider,\n): boolean {\n  return v.validate(response, schemaFormat).valid;\n}\n\nfunction formatErrors(response: IJsonRpcResponse, apiType: string) {\n  if (response) {\n    if (response.error && response.error.message) {\n      // Metamask errors are sometimes full-blown stacktraces, no bueno. Instead,\n      // We'll just take the first line of it, and the last thing after all of\n      // the colons. An example error message would be:\n      // \"Error: Metamask Sign Tx Error: User rejected the signature.\"\n      const lines = response.error.message.split('\\n');\n      if (lines.length > 2) {\n        return lines[0].split(':').pop();\n      } else {\n        return `${response.error.message} ${response.error.data || ''}`;\n      }\n    } else if (response.result && (response as any).status) {\n      return response.result;\n    }\n  }\n  return `Invalid ${apiType} Error`;\n}\n\nenum API_NAME {\n  Get_Balance = 'Get Balance',\n  Estimate_Gas = 'Estimate Gas',\n  Call_Request = 'Call Request',\n  Token_Balance = 'Token Balance',\n  Transaction_Count = 'Transaction Count',\n  Current_Block = 'Current Block',\n  Raw_Tx = 'Raw Tx',\n  Send_Transaction = 'Send Transaction',\n  Sign_Message = 'Sign Message',\n  Get_Accounts = 'Get Accounts',\n  Net_Version = 'Net Version',\n  Transaction_By_Hash = 'Transaction By Hash',\n  Transaction_Receipt = 'Transaction Receipt',\n  Get_Code = 'Get Code',\n}\n\nconst isValidEthCall = (\n  response: IJsonRpcResponse,\n  schemaType: typeof schema.RpcProvider,\n) => (apiName: API_NAME, cb?: (res: IJsonRpcResponse) => any) => {\n  if (!isValidResult(response, schemaType)) {\n    if (cb) {\n      return cb(response);\n    }\n    throw new Error(formatErrors(response, apiName));\n  }\n  return response;\n};\n\nexport const isValidGetBalance = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Get_Balance);\n\nexport const isValidEstimateGas = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Estimate_Gas);\n\nexport const isValidCallRequest = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Call_Request);\n\nexport const isValidTransactionCount = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Transaction_Count);\n\nexport const isValidTransactionByHash = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Transaction_By_Hash);\n\nexport const isValidTransactionReceipt = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Transaction_Receipt);\n\nexport const isValidCurrentBlock = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Current_Block);\n\nexport const isValidRawTxApi = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Raw_Tx);\n\nexport const isValidSendTransaction = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Send_Transaction);\n\nexport const isValidSignMessage = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Sign_Message);\n\nexport const isValidGetAccounts = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Get_Accounts);\n\nexport const isValidGetNetVersion = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Net_Version);\n\nexport const isValidGetCode = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Get_Code);\n","import { StrIdx } from '@src/types';\nimport { randomBytes } from 'crypto';\nimport { IJsonRpcResponse, RPCRequest } from './types';\n\nexport class RPCClient {\n  public endpoint: string;\n  public headers: StrIdx<string>;\n  constructor(endpoint: string, headers: StrIdx<string> = {}) {\n    this.endpoint = endpoint;\n    this.headers = headers;\n  }\n\n  public id(): string | number {\n    return randomBytes(16).toString('hex');\n  }\n\n  public decorateRequest = (req: RPCRequest) => ({\n    ...req,\n    id: this.id(),\n    jsonrpc: '2.0',\n  });\n\n  public call = (request: RPCRequest | any): Promise<IJsonRpcResponse> => {\n    return fetch(this.endpoint, {\n      method: 'POST',\n      headers: this.createHeaders({\n        'Content-Type': 'application/json',\n        ...this.headers,\n      }),\n      body: JSON.stringify(this.decorateRequest(request)),\n    }).then(r => r.json());\n  };\n\n  public batch = (\n    requests: RPCRequest[] | any,\n  ): Promise<IJsonRpcResponse[]> => {\n    return fetch(this.endpoint, {\n      method: 'POST',\n      headers: this.createHeaders({\n        'Content-Type': 'application/json',\n        ...this.headers,\n      }),\n      body: JSON.stringify(requests.map(this.decorateRequest)),\n    }).then(r => r.json());\n  };\n\n  private readonly createHeaders = (headerObject: StrIdx<string>) => {\n    const headers = new Headers();\n    Object.keys(headerObject).forEach(name => {\n      headers.append(name, headerObject[name]);\n    });\n    return headers;\n  };\n}\n","import { IHexStrTransaction, TxObj } from '@src/types';\nimport { stripHexPrefix } from '@src/utils';\nimport {\n  ICallRequest,\n  IEstimateGasRequest,\n  IGetBalanceRequest,\n  IGetCodeRequest,\n  IGetCurrentBlockRequest,\n  IGetNetVersionRequest,\n  IGetTransactionByHashRequest,\n  IGetTransactionCountRequest,\n  IGetTransactionReceiptRequest,\n  ISendRawTxRequest,\n} from './types';\n\nexport class RPCRequests {\n  public getNetVersion(): IGetNetVersionRequest | any {\n    return { method: 'net_version' };\n  }\n\n  public sendRawTx(signedTx: string): ISendRawTxRequest | any {\n    return {\n      method: 'eth_sendRawTransaction',\n      params: [signedTx],\n    };\n  }\n\n  public estimateGas(\n    transaction: Partial<IHexStrTransaction>,\n  ): IEstimateGasRequest | any {\n    return {\n      method: 'eth_estimateGas',\n      params: [transaction],\n    };\n  }\n\n  public getBalance(address: string): IGetBalanceRequest | any {\n    return {\n      method: 'eth_getBalance',\n      params: [`0x${stripHexPrefix(address)}`, 'pending'],\n    };\n  }\n\n  public ethCall(txObj: TxObj): ICallRequest | any {\n    return {\n      method: 'eth_call',\n      params: [txObj, 'pending'],\n    };\n  }\n\n  public getTransactionCount(\n    address: string,\n  ): IGetTransactionCountRequest | any {\n    return {\n      method: 'eth_getTransactionCount',\n      params: [address, 'pending'],\n    };\n  }\n\n  public getTransactionByHash(\n    txhash: string,\n  ): IGetTransactionByHashRequest | any {\n    return {\n      method: 'eth_getTransactionByHash',\n      params: [txhash],\n    };\n  }\n\n  public getTransactionReceipt(\n    txhash: string,\n  ): IGetTransactionReceiptRequest | any {\n    return {\n      method: 'eth_getTransactionReceipt',\n      params: [txhash],\n    };\n  }\n\n  public getCurrentBlock(): IGetCurrentBlockRequest | any {\n    return {\n      method: 'eth_blockNumber',\n    };\n  }\n\n  public getCode(address: string): IGetCodeRequest | any {\n    return {\n      method: 'eth_getCode',\n      params: [`0x${stripHexPrefix(address)}`, 'pending'],\n    };\n  }\n}\n","import {\n  IHexStrTransaction,\n  IRPCProvider,\n  TransactionData,\n  TransactionReceipt,\n  TxObj,\n} from '@src/types';\nimport { hexToNumber, makeBN, Wei } from '@src/utils';\nimport {\n  isValidCallRequest,\n  isValidCurrentBlock,\n  isValidEstimateGas,\n  isValidGetBalance,\n  isValidGetCode,\n  isValidRawTxApi,\n  isValidTransactionByHash,\n  isValidTransactionCount,\n  isValidTransactionReceipt,\n} from '@src/validators';\nimport { RPCClient } from './client';\nimport { RPCRequests } from './requests';\n\nexport class RPCProvider implements IRPCProvider {\n  protected client: RPCClient;\n  protected requests: RPCRequests;\n\n  constructor(endpoint: string) {\n    this.client = new RPCClient(endpoint);\n    this.requests = new RPCRequests();\n  }\n\n  public getNetVersion(): Promise<string> {\n    return this.client\n      .call(this.requests.getNetVersion())\n      .then(({ result }) => result);\n  }\n\n  public ping(): Promise<boolean> {\n    return this.client\n      .call(this.requests.getNetVersion())\n      .then(() => true)\n      .catch(() => false);\n  }\n\n  public sendCallRequest(txObj: TxObj): Promise<string> {\n    return this.client\n      .call(this.requests.ethCall(txObj))\n      .then(isValidCallRequest)\n      .then(response => response.result);\n  }\n\n  public sendCallRequests(txObjs: TxObj[]): Promise<string[]> {\n    return this.client\n      .batch(txObjs.map(this.requests.ethCall))\n      .then(r => r.map(isValidCallRequest))\n      .then(r => r.map(({ result }) => result));\n  }\n\n  public getBalance(address: string): Promise<Wei> {\n    return this.client\n      .call(this.requests.getBalance(address))\n      .then(isValidGetBalance)\n      .then(({ result }) => Wei(result));\n  }\n\n  public estimateGas(transaction: Partial<IHexStrTransaction>): Promise<Wei> {\n    return this.client\n      .call(this.requests.estimateGas(transaction))\n      .then(isValidEstimateGas)\n      .then(({ result }) => Wei(result))\n      .catch(error => {\n        throw new Error(error.message);\n      });\n  }\n\n  public getTransactionCount(address: string): Promise<string> {\n    return this.client\n      .call(this.requests.getTransactionCount(address))\n      .then(isValidTransactionCount)\n      .then(({ result }) => result);\n  }\n\n  public getCurrentBlock(): Promise<string> {\n    return this.client\n      .call(this.requests.getCurrentBlock())\n      .then(isValidCurrentBlock)\n      .then(({ result }) => makeBN(result).toString());\n  }\n\n  public sendRawTx(signedTx: string): Promise<string> {\n    return this.client\n      .call(this.requests.sendRawTx(signedTx))\n      .then(isValidRawTxApi)\n      .then(({ result }) => {\n        return result;\n      });\n  }\n\n  public getTransactionByHash(txhash: string): Promise<TransactionData> {\n    return this.client\n      .call(this.requests.getTransactionByHash(txhash))\n      .then(isValidTransactionByHash)\n      .then(({ result }) => ({\n        ...result,\n        to: result.to || '0x0',\n        value: Wei(result.value),\n        gasPrice: Wei(result.gasPrice),\n        gas: Wei(result.gas),\n        nonce: hexToNumber(result.nonce),\n        blockNumber: result.blockNumber\n          ? hexToNumber(result.blockNumber)\n          : null,\n        transactionIndex: result.transactionIndex\n          ? hexToNumber(result.transactionIndex)\n          : null,\n      }));\n  }\n\n  public getTransactionReceipt(txhash: string): Promise<TransactionReceipt> {\n    return this.client\n      .call(this.requests.getTransactionReceipt(txhash))\n      .then(isValidTransactionReceipt)\n      .then(({ result }) => ({\n        ...result,\n        transactionIndex: hexToNumber(result.transactionIndex),\n        blockNumber: hexToNumber(result.blockNumber),\n        cumulativeGasUsed: Wei(result.cumulativeGasUsed),\n        gasUsed: Wei(result.gasUsed),\n        status: result.status ? hexToNumber(result.status) : null,\n        root: result.root || null,\n      }));\n  }\n\n  public getCode(address: string): Promise<string> {\n    return this.client\n      .call(this.requests.getCode(address))\n      .then(isValidGetCode)\n      .then(({ result }) => result);\n  }\n}\n","import { StrIdx } from '@src/types';\nimport btoa from 'btoa';\nimport { RPCProvider } from '../rpc';\nimport { RPCClient } from '../rpc/client';\n\ninterface IMyCryptoCustomProviderConfig {\n  url: string;\n  auth?: {\n    username: string;\n    password: string;\n  };\n}\n\nexport class MyCryptoCustomProvider extends RPCProvider {\n  constructor(config: IMyCryptoCustomProviderConfig) {\n    super(config.url);\n\n    const headers: StrIdx<string> = {};\n    if (config.auth) {\n      const { username, password } = config.auth;\n      headers.Authorization = `Basic ${btoa(`${username}:${password}`)}`;\n    }\n\n    this.client = new RPCClient(config.url, headers);\n  }\n}\n","import URLSearchParams from 'url-search-params';\nimport { RPCClient } from '../rpc/client';\nimport { IJsonRpcResponse } from '../rpc/types';\nimport { EtherscanRequest } from './types';\n\nexport class EtherscanClient extends RPCClient {\n  public encodeRequest(request: EtherscanRequest): string {\n    const encoded = new URLSearchParams();\n    Object.keys(request).forEach((key: keyof EtherscanRequest) => {\n      if (request[key]) {\n        encoded.set(key, request[key]);\n      }\n    });\n    return encoded.toString();\n  }\n\n  public call = (request: EtherscanRequest): Promise<IJsonRpcResponse> =>\n    fetch(this.endpoint, {\n      method: 'POST',\n      headers: new Headers({\n        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n      }),\n      body: this.encodeRequest(request),\n    }).then(r => r.json());\n\n  public batch = (\n    requests: EtherscanRequest[],\n  ): Promise<IJsonRpcResponse[]> => {\n    const promises = requests.map(req => this.call(req));\n    return Promise.all(promises);\n  };\n}\n","import { IHexStrTransaction } from '@src/types';\nimport { RPCRequests } from '../rpc/requests';\nimport {\n  ICallRequest,\n  IEstimateGasRequest,\n  IGetBalanceRequest,\n  IGetCurrentBlockRequest,\n  IGetTransactionByHashRequest,\n  IGetTransactionCountRequest,\n  IGetTransactionReceiptRequest,\n  ISendRawTxRequest,\n} from './types';\n\nexport class EtherscanRequests extends RPCRequests {\n  public sendRawTx(signedTx: string): ISendRawTxRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_sendRawTransaction',\n      hex: signedTx,\n    };\n  }\n\n  public estimateGas(\n    transaction: Pick<\n      IHexStrTransaction & { from: string },\n      'to' | 'data' | 'from' | 'value'\n    >,\n  ): IEstimateGasRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_estimateGas',\n      to: transaction.to,\n      value: transaction.value,\n      data: transaction.data,\n      from: transaction.from,\n    };\n  }\n\n  public getBalance(address: string): IGetBalanceRequest {\n    return {\n      module: 'account',\n      action: 'balance',\n      tag: 'latest',\n      address,\n    };\n  }\n\n  public ethCall(\n    transaction: Pick<IHexStrTransaction, 'to' | 'data'>,\n  ): ICallRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_call',\n      to: transaction.to,\n      data: transaction.data,\n    };\n  }\n\n  public getTransactionByHash(txhash: string): IGetTransactionByHashRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_getTransactionByHash',\n      txhash,\n    };\n  }\n\n  public getTransactionReceipt(txhash: string): IGetTransactionReceiptRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_getTransactionReceipt',\n      txhash,\n    };\n  }\n\n  public getTransactionCount(address: string): IGetTransactionCountRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_getTransactionCount',\n      tag: 'latest',\n      address,\n    };\n  }\n\n  public getCurrentBlock(): IGetCurrentBlockRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_blockNumber',\n    };\n  }\n}\n","import { RPCProvider } from '../rpc';\nimport { EtherscanClient } from './client';\nimport { EtherscanRequests } from './requests';\n\nexport class EtherscanProvider extends RPCProvider {\n  public client: EtherscanClient;\n  public requests: EtherscanRequests;\n\n  constructor(endpoint: string) {\n    super(endpoint);\n    this.client = new EtherscanClient(endpoint);\n    this.requests = new EtherscanRequests();\n  }\n}\n","import { randomBytes } from 'crypto';\nimport { RPCClient } from '../rpc/client';\n\nexport class InfuraClient extends RPCClient {\n  public id(): number {\n    return parseInt(randomBytes(5).toString('hex'), 16);\n  }\n}\n","import { RPCProvider } from '../rpc';\nimport { InfuraClient } from './client';\n\nexport class InfuraProvider extends RPCProvider {\n  public client: InfuraClient;\n\n  constructor(endpoint: string) {\n    super(endpoint);\n    this.client = new InfuraClient(endpoint);\n  }\n}\n","import { RPCClient } from '../rpc/client';\nimport { IJsonRpcResponse, RPCRequest } from '../rpc/types';\nimport { IWeb3Provider } from './types';\n\nexport class Web3Client extends RPCClient {\n  private readonly provider: IWeb3Provider;\n\n  constructor() {\n    super('web3'); // initialized with fake endpoint\n    this.provider = (window as any).web3.currentProvider;\n  }\n\n  public decorateRequest = (req: RPCRequest) => ({\n    ...req,\n    id: this.id(),\n    jsonrpc: '2.0',\n    params: req.params || [], // default to empty array so MetaMask doesn't error\n  });\n\n  public call = (request: RPCRequest | any): Promise<IJsonRpcResponse> =>\n    this.sendAsync(this.decorateRequest(request)) as Promise<IJsonRpcResponse>;\n\n  public batch = (requests: RPCRequest[] | any): Promise<IJsonRpcResponse[]> =>\n    this.sendAsync(requests.map(this.decorateRequest)) as Promise<\n      IJsonRpcResponse[]\n    >;\n\n  private readonly sendAsync = (\n    request: any,\n  ): Promise<IJsonRpcResponse | IJsonRpcResponse[]> => {\n    return new Promise((resolve, reject) => {\n      this.provider.sendAsync(\n        request,\n        (error, result: IJsonRpcResponse | IJsonRpcResponse[]) => {\n          if (error) {\n            return reject(error);\n          }\n          resolve(result);\n        },\n      );\n    });\n  };\n}\n","import { IHexStrWeb3Transaction } from '@src/types';\nimport { RPCRequests } from '../rpc/requests';\nimport {\n  IGetAccountsRequest,\n  ISendTransactionRequest,\n  ISignMessageRequest,\n} from './types';\n\nexport class Web3Requests extends RPCRequests {\n  public sendTransaction(\n    web3Tx: IHexStrWeb3Transaction,\n  ): ISendTransactionRequest {\n    return {\n      method: 'eth_sendTransaction',\n      params: [web3Tx],\n    };\n  }\n\n  public signMessage(msgHex: string, fromAddr: string): ISignMessageRequest {\n    return {\n      method: 'personal_sign',\n      params: [msgHex, fromAddr],\n    };\n  }\n\n  public getAccounts(): IGetAccountsRequest {\n    return {\n      method: 'eth_accounts',\n    };\n  }\n}\n","import { IHexStrWeb3Transaction, IProvider } from '@src/types';\nimport {\n  isValidGetAccounts,\n  isValidGetNetVersion,\n  isValidSendTransaction,\n  isValidSignMessage,\n} from '@src/validators';\nimport { RPCProvider } from '../rpc';\nimport { Web3Client } from './client';\nimport { Web3Requests } from './requests';\n\nexport class Web3Provider extends RPCProvider {\n  public client: Web3Client;\n  public requests: Web3Requests;\n\n  constructor() {\n    super('web3'); // initialized with fake endpoint\n    this.client = new Web3Client();\n    this.requests = new Web3Requests();\n  }\n\n  public getNetVersion(): Promise<string> {\n    return this.client\n      .call(this.requests.getNetVersion())\n      .then(isValidGetNetVersion)\n      .then(({ result }) => result);\n  }\n\n  public sendTransaction(web3Tx: IHexStrWeb3Transaction): Promise<string> {\n    return this.client\n      .call(this.requests.sendTransaction(web3Tx))\n      .then(isValidSendTransaction)\n      .then(({ result }) => result);\n  }\n\n  public signMessage(msgHex: string, fromAddr: string): Promise<string> {\n    return this.client\n      .call(this.requests.signMessage(msgHex, fromAddr))\n      .then(isValidSignMessage)\n      .then(({ result }) => result);\n  }\n\n  public getAccounts(): Promise<string> {\n    return this.client\n      .call(this.requests.getAccounts())\n      .then(isValidGetAccounts)\n      .then(({ result }) => result);\n  }\n}\n\nexport function isWeb3Provider(\n  provider: IProvider | Web3Provider,\n): provider is Web3Provider {\n  return provider instanceof Web3Provider;\n}\n\nexport const Web3Service = 'MetaMask / Mist';\n\nexport async function setupWeb3Provider() {\n  const { web3 } = window as any;\n\n  if (!web3 || !web3.currentProvider || !web3.currentProvider.sendAsync) {\n    throw new Error(\n      'Web3 not found. Please check that MetaMask is installed, or that MyEtherWallet is open in Mist.',\n    );\n  }\n\n  const provider = new Web3Provider();\n  const networkId = await provider.getNetVersion();\n  const accounts = await provider.getAccounts();\n\n  if (!accounts.length) {\n    throw new Error('No accounts found in MetaMask / Mist.');\n  }\n\n  if (networkId === 'loading') {\n    throw new Error(\n      'MetaMask / Mist is still loading. Please refresh the page and try again.',\n    );\n  }\n\n  return { networkId, provider };\n}\n\nexport async function isWeb3ProviderAvailable(): Promise<boolean> {\n  try {\n    await setupWeb3Provider();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n","import { MyCryptoCustomProvider } from '@src/providers/custom';\nimport { EtherscanProvider } from '@src/providers/etherscan';\nimport { InfuraProvider } from '@src/providers/infura';\nimport { RPCProvider } from '@src/providers/rpc';\nimport { Web3Provider } from '@src/providers/web3';\nimport {\n  IProvider,\n  IProviderContructor,\n  IRPCProvider,\n  IRPCProviderContructor,\n  StrIdx,\n} from '@src/types';\n\ninterface IProviderStorage {\n  setClass(\n    providerName: string,\n    Provider: IProviderContructor | IRPCProviderContructor,\n  ): void;\n  getClass(providerName: string): IProviderContructor | IRPCProviderContructor;\n  setInstance(providerName: string, provider: IProvider | IRPCProvider): void;\n  getInstance(providerName: string): IProvider | IRPCProvider;\n}\n\nclass ProviderStorage implements IProviderStorage {\n  private readonly instances: Partial<StrIdx<IProvider | IRPCProvider>>;\n  private readonly classes: Partial<\n    StrIdx<IProviderContructor | IRPCProviderContructor>\n  >;\n\n  constructor(\n    providers: StrIdx<IProviderContructor | IRPCProviderContructor> = {},\n  ) {\n    this.classes = providers;\n    this.instances = {};\n  }\n\n  /**\n   * Sets the class\n   * @param providerName\n   * @param Provider\n   */\n  public setClass(\n    providerName: string,\n    Provider: IProviderContructor | IRPCProviderContructor,\n  ) {\n    this.classes[providerName] = Provider;\n  }\n\n  public getClass(providerName: string) {\n    const Provider = this.classes[providerName];\n    if (!Provider) {\n      throw Error(`${providerName} implementation does not exist in storage`);\n    }\n    return Provider;\n  }\n\n  public setInstance(providerName: string, provider: IProvider | IRPCProvider) {\n    this.instances[providerName] = provider;\n  }\n\n  public getInstance(providerName: string) {\n    const provider = this.instances[providerName];\n    if (!provider) {\n      throw Error(`${providerName} instance does not exist in storage`);\n    }\n    return provider;\n  }\n}\n\nexport const providerStorage = new ProviderStorage({\n  rpc: RPCProvider,\n  etherscan: EtherscanProvider,\n  infura: InfuraProvider,\n  web3: Web3Provider,\n  myccustom: MyCryptoCustomProvider,\n});\n","import { getRootState } from '@src/ducks/rootState';\nimport { providerStorage } from '@src/providers/providerStorage';\nimport { AllProviderMethods, RootState } from '@src/types';\nimport { IProviderConfigState } from './types';\n\nexport const getProviderConfigs = (state: RootState) =>\n  getRootState(state).providerConfigs;\n\nexport const getProviderConfigById = (\n  state: RootState,\n  id: string,\n): IProviderConfigState[string] | undefined => getProviderConfigs(state)[id];\n\nexport const providerSupportsMethod = (\n  state: RootState,\n  id: string,\n  method: AllProviderMethods,\n): boolean => {\n  const config = getProviderConfigById(state, id);\n  return !!(config && config.supportedMethods[method]);\n};\n\nexport const getProviderTimeoutThreshold = (state: RootState, id: string) => {\n  const config = getProviderConfigById(state, id);\n  if (!config) {\n    throw Error(`Could not find config for provider ${id}`);\n  }\n  return config.timeoutThresholdMs;\n};\n\nexport const getProviderInstAndTimeoutThreshold = (\n  state: RootState,\n  id: string,\n) => {\n  const provider = providerStorage.getInstance(id);\n  const timeoutThreshold = getProviderTimeoutThreshold(state, id);\n  return { provider, timeoutThreshold };\n};\n","import { addProviderConfig, IProviderConfig } from '@src/ducks/providerConfigs';\nimport { storeManager } from '@src/ducks/store';\nimport { IProviderContructor } from '@src/types';\nimport { providerStorage } from './providerStorage';\n\nexport function addProvider(\n  providerName: string,\n  Provider: IProviderContructor,\n) {\n  return providerStorage.setClass(providerName, Provider);\n}\n\nexport function useProvider(\n  providerName: string,\n  instanceName: string,\n  config: IProviderConfig,\n  ...args: any[]\n) {\n  const Provider = providerStorage.getClass(providerName);\n  const provider = new Provider(...args);\n  providerStorage.setInstance(instanceName, provider);\n  const action = addProviderConfig({ config, id: instanceName });\n  storeManager.getStore().dispatch(action);\n  return config;\n}\n","import { AllProviderMethods } from '@src/types';\n\nexport const allRPCMethods: (AllProviderMethods)[] = [\n  'ping',\n  'getNetVersion',\n  'sendCallRequest',\n  'sendCallRequests',\n  'getBalance',\n  'estimateGas',\n  'getTransactionCount',\n  'getTransactionReceipt',\n  'getTransactionByHash',\n  'getCurrentBlock',\n  'sendRawTx',\n  'getCode',\n\n  /*web3 specific methods */\n  'sendTransaction',\n  'signMessage',\n];\n","import { getManualMode } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  IProviderCall,\n  IProviderCallFailed,\n  IProviderCallFlushed,\n  IProviderCallSucceeded,\n  PROVIDER_CALL,\n  providerCallRequested,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { storeManager } from '@src/ducks/store';\nimport { subscribeToAction } from '@src/ducks/subscribe';\nimport { triggerOnMatchingCallId } from '@src/ducks/subscribe/utils';\nimport { AllProviderMethods, IProvider, Reject, Resolve } from '@src/types';\nimport { idGeneratorFactory } from '@src/utils/idGenerator';\nimport { logger } from '@src/utils/logging';\nimport { allRPCMethods } from './constants';\n\nconst idGenerator = idGeneratorFactory();\n\nconst respondToCallee = (resolve: Resolve, reject: Reject) => (\n  action: IProviderCallFailed | IProviderCallSucceeded | IProviderCallFlushed,\n) => {\n  if (action.type === PROVIDER_CALL.SUCCEEDED) {\n    const { providerCall, result } = action.payload;\n\n    logger.log(`CallId: ${providerCall.callId} Pid: ${providerCall.providerId}\n     ${providerCall.rpcMethod} ${providerCall.rpcArgs}\n     Result: ${result}`);\n\n    resolve(action.payload.result);\n  } else {\n    reject(Error(action.payload.error));\n  }\n};\n\nconst makeProviderCall = (\n  rpcMethod: AllProviderMethods,\n  rpcArgs: string[],\n): IProviderCall => {\n  const isManual = getManualMode(storeManager.getStore().getState());\n\n  const providerCall: IProviderCall = {\n    callId: idGenerator(),\n    numOfRetries: 0,\n    rpcArgs,\n    rpcMethod,\n    minPriorityProviderList: [],\n    ...(isManual ? { providerWhiteList: [isManual] } : {}),\n  };\n\n  return providerCall;\n};\n\nconst dispatchRequest = (providerCall: IProviderCall) => {\n  // make the request to the load balancer\n  const networkReq = providerCallRequested(providerCall);\n  storeManager.getStore().dispatch(networkReq);\n  return networkReq.payload.callId;\n};\n\nconst waitForResponse = (callId: number) =>\n  new Promise((resolve, reject) =>\n    storeManager.getStore().dispatch(\n      subscribeToAction({\n        trigger: triggerOnMatchingCallId(callId, false),\n        callback: respondToCallee(resolve, reject),\n      }),\n    ),\n  );\n\nconst providerCallDispatcher = (rpcMethod: AllProviderMethods) => (\n  ...rpcArgs: string[]\n) => {\n  const providerCall = makeProviderCall(rpcMethod, rpcArgs);\n  const callId = dispatchRequest(providerCall);\n  return waitForResponse(callId);\n};\n\nconst handler: ProxyHandler<IProvider> = {\n  get: (target, methodName: AllProviderMethods) => {\n    if (!allRPCMethods.includes(methodName)) {\n      return target[methodName];\n    }\n    return providerCallDispatcher(methodName);\n  },\n};\n\nexport const createProviderProxy = () => new Proxy({} as IProvider, handler);\n","import {\n  balancerInit,\n  balancerNetworkSwitchRequested,\n  setAuto,\n  setManualRequested,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { getManualMode } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport { IProviderConfig } from '@src/ducks/providerConfigs';\nimport { storeManager } from '@src/ducks/store';\nimport {\n  waitForManualMode,\n  waitForNetworkSwitch,\n} from '@src/ducks/subscribe/utils';\nimport { IProviderContructor } from '@src/types';\nimport { IInitConfig, IShepherd } from '@src/types/api';\nimport { logger } from '@src/utils/logging';\nimport { addProvider, createProviderProxy, useProvider } from './providers';\n\nclass Shepherd implements IShepherd {\n  /**\n   *\n   * @description Initializes the balancer, returning a single instance of a provider to be used across your application\n   * @param {IInitConfig} [{ customProviders, ...config }={}] Initialization configuration parameter, custom providers are\n   * your own supplied implementations that adhere to the {IProvider} interface. The {providerCallRetryThreshold} determines\n   * how many times a provider can fail a call before its determined to be offline. The {network} is what network the balancer\n   * will initialize to, defaulting to 'ETH'. The {storeRoot} is the shepherd rootReducer when using a custom store.\n   * E.g If the top level is { foo, shepherdReducer } then `storeRoot` would be `shepherdReducer`. Note that this setting only supports one level of nesting.\n   * The {store} is the custom store to use if you want to use your own, make sure to supply the setting above too or else it will not work.\n   * {queueTimeout} is the timeout based on when there are pending calls that have not been assigned to a worker. The most common case of this happening\n   * is when the balancer is offline and there's calls to the balancer still happening.\n   * @returns {Promise<IProvider>} A provider instances to be used for making rpc calls\n   * @memberof Shepherd\n   */\n  public async init({\n    customProviders,\n    storeRoot,\n    store,\n    ...config\n  }: IInitConfig = {}) {\n    if (storeRoot) {\n      storeManager.setRoot(storeRoot);\n    }\n\n    if (store) {\n      storeManager.setStore(store);\n    }\n\n    if (customProviders) {\n      for (const [customProviderName, Provider] of Object.entries(\n        customProviders,\n      )) {\n        addProvider(customProviderName, Provider);\n      }\n    }\n\n    if (!config.network) {\n      config.network = 'ETH';\n    }\n\n    if (!config.providerCallRetryThreshold) {\n      config.providerCallRetryThreshold = 3;\n    }\n    const node = createProviderProxy();\n    const initAction = balancerInit(config);\n\n    const promise = waitForNetworkSwitch(\n      storeManager.getStore().dispatch,\n      initAction.meta.id,\n    );\n\n    storeManager.getStore().dispatch(initAction);\n    await promise;\n    return node;\n  }\n\n  /**\n   *\n   * @description Adds a custom Provider implementation to be later used and instantiated by useProvider.\n   * This library comes with default Provider implementations of 'rpc' 'etherscan' 'infura' 'web3' 'myccustom'\n   * already availble for use in useProvider. This method can be used before init\n   * @param {string} providerName\n   * @param {IProviderContructor} Provider The provider implementation to store for later usage\n   * @returns {void}\n   * @memberof Shepherd\n   */\n  public addProvider(providerName: string, Provider: IProviderContructor) {\n    addProvider(providerName, Provider);\n  }\n\n  /**\n   * @description Switches the balancer back to \"auto\" mode. This is the default mode of the balancer.\n   * If the balancer was previously in \"manual\" mode, this will now instead change it back to normal\n   * behaviour, which means balancing between all available providers of the current network\n   * @returns {void}\n   * @memberof Shepherd\n   */\n  public auto() {\n    storeManager.getStore().dispatch(setAuto());\n  }\n\n  /**\n   *\n   * @description Switches the balancer to \"manual\" mode. This will switch the balancer's current network\n   * to the manual providers network if it is different, then route all requests to the provider. This method\n   * can be used before init\n   * @param {string} providerId\n   * @param {boolean} skipOfflineCheck Will not fail and throw an error if the manual provider switched to\n   * is offline\n   * @returns {Promise<string>} Resolves when the manual provider has successfully been switched to,\n   * returns a promise containing the provider ID switched to\n   * @memberof Shepherd\n   */\n  public async manual(providerId: string, skipOfflineCheck: boolean) {\n    const promise = waitForManualMode(storeManager.getStore().dispatch);\n    storeManager\n      .getStore()\n      .dispatch(setManualRequested({ providerId, skipOfflineCheck }));\n    return await promise;\n  }\n\n  /**\n   * @description Add a provider instance to the balancer to be used for incoming rpc calls,\n   * this is distinctly different from addProvider, as addProvider does not add any providers to be\n   * used for incoming calls. All addProvider does is add a custom implementation to the pool of default\n   * implementations that you can specify in this method to be used and have instances created from.\n   * This method can be used before init\n   * @param {string} providerName The name of the Provider implementation to use as previously defined in\n   * either init (as customProviders), or addProvider, or one of the default implementations supplied:\n   * 'rpc' 'etherscan' 'infura' 'web3' 'myccustom'\n   * @param {string} instanceName The unique name of the instance to be used\n   * @param {IProviderConfig} config\n   * @param {...any[]} args The constructor arguments to be supplied to the specifed Provider constructor\n   * @returns {void}\n   * @memberof Shepherd\n   */\n  public useProvider(\n    providerName: string,\n    instanceName: string,\n    config: IProviderConfig,\n    ...args: any[]\n  ) {\n    useProvider(providerName, instanceName, config, ...args);\n  }\n\n  /**\n   * @description Switch the network for the balancer to use, all provider instances added by useProvider\n   * that match the same network to be swiched to will be used. Can not be used when the balancer is in\n   * manual mode, switch to auto mode first.\n   * @param {string} network\n   * @returns {Promise<void>} Resolves when the network is finished being switched to\n   * @memberof Shepherd\n   */\n  public async switchNetworks(network: string) {\n    if (getManualMode(storeManager.getStore().getState())) {\n      throw Error(`Can't switch networks when in manual mode!`);\n    }\n    const action = balancerNetworkSwitchRequested({ network });\n\n    const promise = waitForNetworkSwitch(\n      storeManager.getStore().dispatch,\n      action.meta.id,\n    );\n    storeManager.getStore().dispatch(action);\n    await promise;\n  }\n\n  /**\n   * @description enables logging for the library\n   * @memberof Shepherd\n   */\n  public enableLogging() {\n    logger.enableLogging();\n  }\n}\n\nexport const shepherd = new Shepherd();\n","import { AllActions } from '@src/ducks/types';\nimport { Dispatch, Middleware } from 'redux';\n\nimport { SUBSCRIBE } from '@src/ducks/subscribe';\n// this should be the last middleware, immediately before the store\n// if it's an subscription action then do not dispatch it to the store\nexport const filterMiddlware: Middleware = () => (\n  next: Dispatch<AllActions>,\n) => (action: AllActions): any =>\n  action.type === SUBSCRIBE.ACTION ? undefined : next(action);\n","import { combineReducers } from 'redux';\nimport { balancerConfigReducer } from './balancerConfig';\nimport * as balancerConfigSelectors from './balancerConfig/selectors';\n\nimport { providerCallsReducer } from './providerCalls';\nimport * as providerCallsSelectors from './providerCalls/selectors';\n\nimport { providerStatsReducer } from './providerStats';\nimport * as providerStatsSelectors from './providerStats/selectors';\n\nimport { workerReducer } from './workers';\nimport * as workersSelectors from './workers/selectors';\n\nimport { IProviderBalancerState } from './types';\nexport * from './types';\n\nexport const providerBalancer = combineReducers<IProviderBalancerState>({\n  providerStats: providerStatsReducer,\n  workers: workerReducer,\n  balancerConfig: balancerConfigReducer,\n  providerCalls: providerCallsReducer,\n});\n\nexport const providerBalancerSelectors = {\n  balancerConfigSelectors,\n  providerCallsSelectors,\n  providerStatsSelectors,\n  workersSelectors,\n};\n","import { ISubscribe, SUBSCRIBE } from '@src/ducks/subscribe';\nimport { SagaIterator } from 'redux-saga';\nimport { take, takeEvery } from 'redux-saga/effects';\n\nfunction* handleSubscribeToAction({ payload }: ISubscribe): SagaIterator {\n  const { trigger, callback } = payload;\n  const resultingAction = yield take(trigger);\n  callback(resultingAction);\n}\n\nexport const subscriptionWatcher = [\n  takeEvery(SUBSCRIBE.ACTION, handleSubscribeToAction),\n];\n","import { IBalancerNetworkSwitchSucceeded } from '@src/ducks/providerBalancer/balancerConfig';\nimport {\n  IProviderCall,\n  ProviderCallWithPid,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport {\n  IProviderStats,\n  ProcessedProvider,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { IWorker } from '@src/ducks/providerBalancer/workers';\nimport { Task } from 'redux-saga';\n\nexport const createRetryCall = (\n  currentCall: ProviderCallWithPid,\n): IProviderCall => {\n  const { providerId } = currentCall;\n  const currMinList = currentCall.minPriorityProviderList;\n  const nextMinPriorityList = currMinList.includes(providerId)\n    ? currMinList\n    : [...currMinList, providerId];\n\n  const nextCall = {\n    ...currentCall,\n    minPriorityProviderList: nextMinPriorityList,\n    numOfRetries: ++currentCall.numOfRetries,\n  };\n\n  return nextCall;\n};\n\nexport const addProviderIdToCall = (\n  call: IProviderCall,\n  providerId: string,\n): ProviderCallWithPid => ({\n  ...call,\n  providerId,\n});\n\nexport const trackTime = () => {\n  const startTime = new Date();\n  return {\n    end() {\n      const endTime = new Date();\n      const avgResponseTime = +endTime - +startTime;\n      return avgResponseTime;\n    },\n  };\n};\n\nexport const makeProviderStats = (\n  timer: any,\n  isOffline: boolean,\n): IProviderStats => ({\n  avgResponseTime: timer.end(),\n  isOffline,\n  currWorkersById: [],\n  requestFailures: 0,\n});\n\nexport const makeWorkerId = (providerId: string, workerNumber: number) =>\n  `${providerId}_worker_${workerNumber}`;\n\nexport const makeWorker = (providerId: string, task: Task): IWorker => ({\n  assignedProvider: providerId,\n  currentPayload: null,\n  task,\n});\n\ntype NetworkPayload = IBalancerNetworkSwitchSucceeded['payload'];\n\nexport const reduceProcessedProviders = (\n  processedProviders: ProcessedProvider[],\n  network: string,\n): NetworkPayload => {\n  const initialState: NetworkPayload = {\n    providerStats: {},\n    workers: {},\n    network,\n  };\n\n  return processedProviders.reduce((accu, currProvider) => {\n    const curProviderStats: NetworkPayload['providerStats'] = {\n      [currProvider.providerId]: currProvider.stats,\n    };\n\n    const providerStats: NetworkPayload['providerStats'] = {\n      ...accu.providerStats,\n      ...curProviderStats,\n    };\n\n    const workers: NetworkPayload['workers'] = {\n      ...accu.workers,\n      ...currProvider.workers,\n    };\n\n    return {\n      ...accu,\n      providerStats,\n      workers,\n    };\n  }, initialState);\n};\n\nexport const makeRetVal = (\n  error: Error | null = null,\n  result: string | null = null,\n) => ({ result, error });\n","import {\n  IProviderCallRequested,\n  providerCallFlushed,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { subscribeToAction } from '@src/ducks/subscribe';\nimport { triggerOnMatchingCallId } from '@src/ducks/subscribe/utils';\nimport { Channel, SagaIterator } from 'redux-saga';\nimport { apply, flush, put, take } from 'redux-saga/effects';\n\nexport abstract class BaseChannel {\n  protected chan: Channel<IProviderCallRequested> | undefined;\n  protected name: string | undefined;\n  private currentAction: IProviderCallRequested | null | undefined;\n  private readonly shouldLog = false;\n\n  public get() {\n    if (!this.chan) {\n      throw Error(`Channel not assigned yet`);\n    }\n\n    return this.chan;\n  }\n\n  public abstract init(): void;\n\n  public *take(): SagaIterator {\n    const action: IProviderCallRequested = yield take(this.get());\n    // set the current action, so when we flush all of the actions we dont miss the currently processing one\n    const callid = action.payload.callId;\n    this.currentAction = action;\n    this.log(`took call`, action.payload.callId);\n\n    // set the current action to null when it isnt in a state of \"requested\"\n    yield put(\n      subscribeToAction({\n        trigger: triggerOnMatchingCallId(\n          this.currentAction.payload.callId,\n          true,\n        ),\n        callback: () => {\n          this.log(\n            `call ${this.currentAction &&\n              this.currentAction.payload.callId} is now null `,\n          );\n          this.currentAction = null;\n        },\n      }),\n    );\n    this.log(`Returning ${this.currentAction} ${callid}`);\n    return this.currentAction;\n  }\n\n  public *cancelPendingCalls(): SagaIterator {\n    const pendingCalls: IProviderCallRequested[] = yield apply(\n      this,\n      this.getPendingCalls,\n    );\n    for (const { payload } of pendingCalls) {\n      yield put(\n        providerCallFlushed({\n          error: 'Call Flushed',\n          providerCall: payload,\n        }),\n      );\n    }\n  }\n\n  protected log(...args: any[]) {\n    if (this.shouldLog) {\n      console.log(this.name, ...args);\n    }\n  }\n\n  private *flushChannel(): SagaIterator {\n    const messages = yield flush(this.get());\n    this.log(`flushing`);\n    this.log(messages);\n    return messages;\n  }\n\n  private *getPendingCalls(): SagaIterator {\n    const queuedCalls = yield apply(this, this.flushChannel);\n    const pendingCalls = this.currentAction\n      ? [...queuedCalls, this.currentAction]\n      : queuedCalls;\n\n    this.log(`get pending calls`);\n    this.log(pendingCalls);\n\n    this.currentAction = null;\n    return pendingCalls;\n  }\n}\n","import { PROVIDER_CALL } from '@src/ducks/providerBalancer/providerCalls';\nimport { BaseChannel } from '@src/saga/channels/base';\nimport { buffers, SagaIterator } from 'redux-saga';\nimport { actionChannel } from 'redux-saga/effects';\n\nexport class BalancerChannel extends BaseChannel {\n  public name = 'Balancer Channel';\n\n  public *init(): SagaIterator {\n    this.chan = yield actionChannel(\n      PROVIDER_CALL.REQUESTED,\n      buffers.expanding(50),\n    );\n  }\n}\n","import { BaseChannel } from '@src/saga/channels/base';\nimport { buffers, channel } from 'redux-saga';\nimport { apply, call } from 'redux-saga/effects';\n\nclass ProviderChannel extends BaseChannel {\n  public name = 'Provider Channel';\n  public *init() {\n    this.chan = yield call(channel, buffers.expanding(10));\n  }\n}\n\nexport function* providerChannelFactory() {\n  const chan = new ProviderChannel();\n  yield apply(chan, chan.init);\n  return chan;\n}\n","import {\n  IProviderCall,\n  IProviderCallRequested,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { BaseChannel } from '@src/saga/channels/base';\nimport { providerChannelFactory } from '@src/saga/channels/providerChannel';\nimport { StrIdx } from '@src/types';\nimport { SagaIterator } from 'redux-saga';\nimport { apply, call, put } from 'redux-saga/effects';\n\nexport class ProviderChannels {\n  private readonly providerChannels: StrIdx<BaseChannel>;\n\n  constructor() {\n    this.providerChannels = {};\n  }\n\n  public *put(\n    providerId: string,\n    action: IProviderCallRequested,\n  ): SagaIterator {\n    const chan = this.getChannel(providerId).get();\n    yield put(chan, action);\n  }\n\n  public *createChannel(providerId: string): SagaIterator {\n    if (this.providerChannels[providerId]) {\n      throw Error(`${providerId} already has an existing channel open`);\n    }\n\n    const providerChannel: BaseChannel = yield call(providerChannelFactory);\n    this.providerChannels[providerId] = providerChannel;\n  }\n\n  public *take(providerId: string): SagaIterator {\n    const channel = this.getChannel(providerId);\n    const action: IProviderCall = yield apply(channel, channel.take);\n    return action;\n  }\n\n  public *cancelPendingCalls(): SagaIterator {\n    const chans = Object.values(this.providerChannels);\n    for (const chan of chans) {\n      yield apply(chan, chan.cancelPendingCalls);\n    }\n  }\n\n  public deleteAllChannels() {\n    for (const providerId of Object.keys(this.providerChannels)) {\n      this.deleteChannel(providerId);\n    }\n  }\n\n  private deleteChannel(providerId: string) {\n    //check for existence\n    this.getChannel(providerId);\n    Reflect.deleteProperty(this.providerChannels, providerId);\n  }\n\n  private getChannel(providerId: string) {\n    const channel = this.providerChannels[providerId];\n    if (!channel) {\n      throw Error(`${providerId} does not have an existing channel`);\n    }\n    return channel;\n  }\n}\n","import { BalancerChannel } from './balancerChannel';\nimport { ProviderChannels } from './providerChannels';\nexport const balancerChannel = new BalancerChannel();\nexport const providerChannels = new ProviderChannels();\n","import {\n  IProviderCallRequested,\n  isStaleCall,\n  providerCallFailed,\n  providerCallSucceeded,\n  providerCallTimeout,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { workerProcessing } from '@src/ducks/providerBalancer/workers';\nimport { getProviderInstAndTimeoutThreshold } from '@src/ducks/providerConfigs';\nimport { providerChannels } from '@src/saga/channels';\nimport { addProviderIdToCall, makeRetVal } from '@src/saga/sagaUtils';\nimport { AllProviderMethods } from '@src/types';\nimport { logger } from '@src/utils/logging';\nimport { delay } from 'redux-saga';\nimport { apply, call, cancelled, put, race, select } from 'redux-saga/effects';\n\nconst isWeb3Method = (rpcMethod: AllProviderMethods) =>\n  rpcMethod === 'sendTransaction' || rpcMethod === 'signMessage';\n\nfunction* sendRequestToProvider(\n  providerId: string,\n  rpcMethod: AllProviderMethods,\n  rpcArgs: any,\n) {\n  try {\n    const {\n      provider,\n      timeoutThreshold,\n    }: ReturnType<typeof getProviderInstAndTimeoutThreshold> = yield select(\n      getProviderInstAndTimeoutThreshold,\n      providerId,\n    );\n\n    // make the call in the allotted timeout time\n    const { result } = yield race({\n      result: apply(provider, (provider as any)[rpcMethod], rpcArgs),\n      // HACK: If it's an web3 method, then wait 5 minutes because it can be intercepted (see metamask) and then waits on user confirmation\n      // TODO: refactor this to support web3 providers natively\n      timeout: call(\n        delay,\n        isWeb3Method(rpcMethod) ? 60 * 1000 * 5 : timeoutThreshold,\n      ),\n    });\n\n    if (!result) {\n      const error = Error(`Request timed out for ${providerId}`);\n      return makeRetVal(error);\n    }\n\n    return makeRetVal(null, result);\n  } catch (error) {\n    return makeRetVal(error);\n  }\n}\n\nfunction* processRequest(providerId: string, workerId: string) {\n  // take from the assigned action channel\n  const { payload }: IProviderCallRequested = yield apply(\n    providerChannels,\n    providerChannels.take,\n    [providerId],\n  );\n  const { rpcArgs, rpcMethod } = payload;\n  const callWithPid = addProviderIdToCall(payload, providerId);\n\n  if (yield select(isStaleCall, payload.callId)) {\n    logger.log(`Call ${payload.callId} is stale before processing`);\n    return;\n  }\n  // after taking a request, declare processing state\n  yield put(workerProcessing({ currentPayload: callWithPid, workerId }));\n\n  const { result, error } = yield call(\n    sendRequestToProvider,\n    providerId,\n    rpcMethod,\n    rpcArgs,\n  );\n\n  if (yield select(isStaleCall, payload.callId)) {\n    logger.log(`Call ${payload.callId} is stale after processing`);\n    return;\n  }\n\n  if (result) {\n    const action = providerCallSucceeded({\n      result,\n      providerCall: callWithPid,\n    });\n    return yield put(action);\n  } else {\n    const actionParams = {\n      providerCall: callWithPid,\n      error,\n    };\n    const action = isWeb3Method(rpcMethod)\n      ? providerCallFailed(actionParams)\n      : providerCallTimeout(actionParams);\n\n    return yield put(action);\n  }\n}\n\nfunction* processIncomingRequests(thisId: string, providerId: string) {\n  while (true) {\n    yield call(processRequest, providerId, thisId);\n  }\n}\n\nexport function* createWorker(thisId: string, providerId: string) {\n  try {\n    yield call(processIncomingRequests, thisId, providerId);\n  } catch (e) {\n    console.error(`${thisId} as errored with ${e.message}`);\n  } finally {\n    if (yield cancelled()) {\n      logger.log(`${thisId} has been cancelled`);\n    }\n  }\n}\n","import { IWorker } from '@src/ducks/providerBalancer/workers';\nimport { providerChannels } from '@src/saga/channels';\nimport { makeWorker, makeWorkerId } from '@src/saga/sagaUtils';\nimport { createWorker } from '@src/saga/workers/helpers';\nimport { StrIdx } from '@src/types';\nimport { Task } from 'redux-saga';\nimport { apply, spawn } from 'redux-saga/effects';\n\nexport function* spawnWorkers(\n  providerId: string,\n  currentWorkers: string[],\n  maxNumOfWorkers: number,\n) {\n  const providerChannel = yield apply(\n    providerChannels,\n    providerChannels.createChannel,\n    [providerId],\n  );\n\n  const workers: StrIdx<IWorker> = {};\n\n  for (\n    let workerNumber = currentWorkers.length;\n    workerNumber < maxNumOfWorkers;\n    workerNumber++\n  ) {\n    const workerId = makeWorkerId(providerId, workerNumber);\n    const workerTask: Task = yield spawn(\n      createWorker,\n      workerId,\n      providerId,\n      providerChannel,\n    );\n\n    workers[workerId] = makeWorker(providerId, workerTask);\n  }\n\n  return { workers, workerIds: [...currentWorkers, ...Object.keys(workers)] };\n}\n","import { getProviderTimeoutThreshold } from '@src/ducks/providerConfigs';\nimport { providerStorage } from '@src/providers/providerStorage';\nimport { logger } from '@src/utils/logging';\nimport { delay } from 'redux-saga';\nimport { apply, call, race, select } from 'redux-saga/effects';\n\n/**\n * @description polls the offline state of a provider, then returns control to caller when it comes back online\n * @param {string} providerId\n */\nexport function* checkProviderConnectivity(providerId: string) {\n  const provider = providerStorage.getInstance(providerId);\n  const timeoutThreshold: ReturnType<\n    typeof getProviderTimeoutThreshold\n  > = yield select(getProviderTimeoutThreshold, providerId);\n  try {\n    const { lb } = yield race({\n      lb: apply(provider, provider.getCurrentBlock),\n      to: call(delay, timeoutThreshold),\n    });\n    return !!lb;\n  } catch (error) {\n    logger.log(error);\n  }\n  return false;\n}\n","import {\n  ProcessedProvider,\n  providerOffline,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { IProviderConfig } from '@src/ducks/providerConfigs';\nimport { makeProviderStats, trackTime } from '@src/saga/sagaUtils';\nimport { spawnWorkers } from '@src/saga/workers';\nimport { call, put } from 'redux-saga/effects';\nimport { checkProviderConnectivity } from './connectivity';\n\n/**\n *\n * @description Handles checking if a provider is online or not,\n * and spawning workers for its concurrency rating\n * @param {string} providerId\n * @param {ProviderConfig} config\n */\nexport function* processProvider(\n  providerId: string,\n  { concurrency }: IProviderConfig,\n) {\n  const timer = trackTime();\n  const providerIsOnline: boolean = yield call(\n    checkProviderConnectivity,\n    providerId,\n  );\n\n  const stats = makeProviderStats(timer, !providerIsOnline);\n\n  if (!providerIsOnline) {\n    yield put(providerOffline({ providerId }));\n  }\n\n  const { workers, workerIds } = yield call(\n    spawnWorkers,\n    providerId,\n    stats.currWorkersById,\n    concurrency,\n  );\n\n  stats.currWorkersById = workerIds;\n\n  const processedProvider: ProcessedProvider = { providerId, stats, workers };\n  return processedProvider;\n}\n","import { BALANCER } from '@src/ducks/providerBalancer/balancerConfig';\nimport { getNetwork } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  ProcessedProvider,\n  providerAdded,\n} from '@src/ducks/providerBalancer/providerStats';\nimport {\n  IAddProviderConfig,\n  PROVIDER_CONFIG,\n} from '@src/ducks/providerConfigs/types';\nimport { processProvider } from '@src/saga/helpers/processing';\nimport { call, put, race, select, take, takeEvery } from 'redux-saga/effects';\n\nfunction* handleAddingProviderConfig({\n  payload: { config, id },\n}: IAddProviderConfig) {\n  const network: ReturnType<typeof getNetwork> = yield select(getNetwork);\n  if (network !== config.network) {\n    return;\n  }\n\n  const {\n    processedProvider,\n  }: { processedProvider: ProcessedProvider } = yield race({\n    processedProvider: call(processProvider, id, config),\n    cancelled: take(BALANCER.NETWORK_SWTICH_REQUESTED),\n  });\n\n  if (!processedProvider) {\n    return;\n  }\n\n  yield put(providerAdded(processedProvider));\n}\n\nexport const addProviderConfigWatcher = [\n  takeEvery(PROVIDER_CONFIG.ADD, handleAddingProviderConfig),\n];\n","import {\n  BALANCER,\n  balancerFlush,\n  IBalancerManualSucceeded,\n  IBalancerNetworkSwitchRequested,\n  IBalancerQueueTimeout,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { getWorkers } from '@src/ducks/providerBalancer/workers';\nimport { balancerChannel, providerChannels } from '@src/saga/channels';\nimport { SagaIterator } from 'redux-saga';\nimport {\n  apply,\n  call,\n  cancel,\n  put,\n  select,\n  takeEvery,\n} from 'redux-saga/effects';\n\nfunction* clearWorkers(): SagaIterator {\n  const workers: ReturnType<typeof getWorkers> = yield select(getWorkers);\n  for (const worker of Object.values(workers)) {\n    yield cancel(worker.task);\n  }\n}\n\nfunction* clearAllPendingCalls(): SagaIterator {\n  yield apply(providerChannels, providerChannels.cancelPendingCalls);\n  yield apply(balancerChannel, balancerChannel.cancelPendingCalls);\n}\n\nfunction* deleteProviderChannels() {\n  yield apply(providerChannels, providerChannels.deleteAllChannels);\n}\n\ntype FlushingActions =\n  | IBalancerQueueTimeout\n  | IBalancerNetworkSwitchRequested\n  | IBalancerManualSucceeded;\n\nfunction* clearState({ type }: FlushingActions): SagaIterator {\n  const isNetworkSwitch = type === BALANCER.NETWORK_SWTICH_REQUESTED;\n  yield call(clearAllPendingCalls);\n\n  if (isNetworkSwitch) {\n    yield put(balancerFlush());\n    yield call(clearWorkers);\n    yield call(deleteProviderChannels);\n  }\n}\n\nexport const balancerFlushWatcher = [\n  takeEvery(\n    [\n      BALANCER.NETWORK_SWTICH_REQUESTED,\n      BALANCER.QUEUE_TIMEOUT,\n      BALANCER.MANUAL_SUCCEEDED,\n    ],\n    clearState,\n  ),\n];\n","/**\n * @name filterAgainstArray\n * @description Compares each entry in arr1 against all entries in arr2, if the entry in arr1 matches an entry in arr2 then it is included in the result\n * @param arr1 An array of entries\n * @param arr2 An array of strings to check each entry against\n * @param invert Includes results from arr1 that arent in arr2 instead\n */\nexport const filterAgainstArr = <T>(\n  arr1: T[],\n  arr2: T[],\n  invert: boolean = false,\n) =>\n  arr1.filter(\n    strToCheck =>\n      !invert ? arr2.includes(strToCheck) : !arr2.includes(strToCheck),\n  );\n","import {\n  getManualMode,\n  getNetwork,\n} from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  getPendingProviderCallsByProviderId,\n  IProviderCall,\n  IProviderCallTimeout,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport {\n  getOnlineProviders,\n  getProviderStatsById,\n} from '@src/ducks/providerBalancer/providerStats';\nimport {\n  getProviderConfigById,\n  getProviderConfigs,\n  IProviderConfig,\n  providerSupportsMethod,\n} from '@src/ducks/providerConfigs';\nimport { filterAgainstArr } from '@src/ducks/utils';\nimport { allRPCMethods } from '@src/providers/constants';\nimport { AllProviderMethods, RootState, StrIdx } from '@src/types';\n\nexport const providerExceedsRequestFailureThreshold = (\n  state: RootState,\n  { payload }: IProviderCallTimeout,\n) => {\n  const { providerCall: { providerId } } = payload;\n  const providerStats = getProviderStatsById(state, providerId);\n  const providerConfig = getProviderConfigById(state, providerId);\n\n  if (!providerStats || !providerConfig) {\n    throw Error('Could not find provider stats or config');\n  }\n\n  // if the provider has reached maximum failures, declare it as offline\n  return (\n    providerStats.requestFailures >= providerConfig.requestFailureThreshold\n  );\n};\n\nexport const getAllProvidersOfNetwork = (\n  state: RootState,\n  networkId: string,\n) => {\n  const allProvidersOfNetworkId: StrIdx<IProviderConfig> = {};\n\n  const providerConfigs = getProviderConfigs(state);\n\n  return Object.entries(providerConfigs).reduce(\n    (allProviders, [currProviderId, currProviderConfig]) => {\n      if (currProviderConfig.network !== networkId) {\n        return allProviders;\n      }\n      return { ...allProviders, [currProviderId]: currProviderConfig };\n    },\n    allProvidersOfNetworkId,\n  );\n};\n\nexport const getOnlineProviderIdsOfCurrentNetwork = (state: RootState) => {\n  const network = getNetwork(state);\n  const onlineProviders = getOnlineProviders(state);\n  const providersOfCurrentNetwork = Object.keys(onlineProviders).filter(id => {\n    const config = getProviderConfigById(state, id);\n    return config && config.network === network;\n  });\n  return providersOfCurrentNetwork;\n};\n\nexport const getAllMethodsAvailable = (state: RootState): boolean => {\n  const availableProviderIds = getOnlineProviderIdsOfCurrentNetwork(state);\n  const manualProvider = getManualMode(state);\n\n  // goes through each available provider and reduces all of their\n  // available methods into a mapping that contains all supported methods\n  const availableMethods: { [key in AllProviderMethods]: boolean } = {\n    getNetVersion: false,\n    estimateGas: false,\n    getBalance: false,\n    getCurrentBlock: false,\n    getTransactionCount: false,\n    ping: false,\n    sendCallRequest: false,\n    sendCallRequests: false,\n    sendRawTx: false,\n    getTransactionByHash: false,\n    getTransactionReceipt: false,\n    getCode: false,\n\n    /* Web3 Methods*/\n    sendTransaction: false,\n    signMessage: false,\n  };\n\n  for (const providerId of availableProviderIds) {\n    const providerConfig = getProviderConfigById(state, providerId);\n    if (!providerConfig) {\n      continue;\n    }\n\n    if (manualProvider && providerId !== manualProvider) {\n      continue;\n    }\n\n    // for the current provider config, OR each rpcMethod against the map\n    Object.entries(providerConfig.supportedMethods).forEach(\n      ([rpcMethod, isSupported]: [AllProviderMethods, boolean]) => {\n        availableMethods[rpcMethod] =\n          availableMethods[rpcMethod] || isSupported;\n      },\n    );\n  }\n\n  // check that all methods are supported by the set of all available providers\n  return allRPCMethods.reduce(\n    (allAvailable, curMethod) => allAvailable && availableMethods[curMethod],\n    true,\n  );\n};\n\n// available providers -> providers that support the method -> providers that are whitelisted -> prioritized providers -> workers not busy\n// TODO: include response time in prioritization\nexport const getAvailableProviderId = (\n  state: RootState,\n  payload: IProviderCall,\n) => {\n  const onlineProviders = getOnlineProviderIdsOfCurrentNetwork(state);\n\n  // filter by providers that can support this method\n  const supportsMethod = onlineProviders.filter(providerId =>\n    providerSupportsMethod(state, providerId, payload.rpcMethod),\n  );\n\n  // filter providers that are in the whitelist if it exists, else continue with providers that support the method\n  const payloadProviderWhitelist = payload.providerWhiteList;\n  const isWhitelisted = payloadProviderWhitelist\n    ? filterAgainstArr(supportsMethod, payloadProviderWhitelist)\n    : supportsMethod;\n\n  // grab the providers that are not included in min priority\n  const prioritized1 = filterAgainstArr(\n    isWhitelisted,\n    payload.minPriorityProviderList,\n    true,\n  );\n\n  // grab the providers that are included\n  const prioritized2 = filterAgainstArr(\n    isWhitelisted,\n    payload.minPriorityProviderList,\n  );\n\n  // prioritize the list by using providers with most workers free\n  const listToPrioritizeByWorker =\n    prioritized1.length > 0 ? prioritized1 : prioritized2;\n\n  let prevProvider: {\n    providerId: string;\n    numOfRequestsCurrentProcessing: number;\n  } | null = null;\n\n  for (const currentProviderId of listToPrioritizeByWorker) {\n    const numOfRequestsCurrentProcessing = getPendingProviderCallsByProviderId(\n      state,\n      currentProviderId,\n    );\n\n    // if there's no selected provider yet (aka first iteration)\n    // or\n    // the current provider has less requests processing, switch the next provider to current provider\n    if (\n      !prevProvider ||\n      prevProvider.numOfRequestsCurrentProcessing >\n        numOfRequestsCurrentProcessing\n    ) {\n      prevProvider = {\n        providerId: currentProviderId,\n        numOfRequestsCurrentProcessing,\n      };\n    }\n  }\n\n  return prevProvider ? prevProvider.providerId : null;\n};\n","import {\n  BALANCER,\n  IBalancerAuto,\n  IBalancerManualSucceeded,\n  IBalancerNetworkSwitchRequested,\n  IBalancerNetworkSwitchSucceeded,\n  setOffline,\n  setOnline,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { isOffline } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  PROVIDER_STATS,\n  ProviderStatsAction,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { getAllMethodsAvailable } from '@src/ducks/selectors';\nimport { buffers, SagaIterator } from 'redux-saga';\nimport {\n  actionChannel,\n  call,\n  fork,\n  put,\n  select,\n  take,\n} from 'redux-saga/effects';\n\ntype WatchedActions =\n  | ProviderStatsAction\n  | IBalancerNetworkSwitchRequested\n  | IBalancerNetworkSwitchSucceeded\n  | IBalancerAuto\n  | IBalancerManualSucceeded;\n\nfunction* dispatchOffline() {\n  const offline: ReturnType<typeof isOffline> = yield select(isOffline);\n  if (!offline) {\n    return yield put(setOffline());\n  }\n}\n\nfunction* dispatchOnline() {\n  const offline: ReturnType<typeof isOffline> = yield select(isOffline);\n  const online = !offline;\n  if (!online) {\n    return yield put(setOnline());\n  }\n}\n\nfunction* setBalancerOnlineState({ type }: WatchedActions): SagaIterator {\n  if (type === BALANCER.NETWORK_SWTICH_REQUESTED) {\n    yield call(dispatchOffline);\n    //block until network switch is done\n    return yield take(BALANCER.NETWORK_SWITCH_SUCCEEDED);\n  }\n\n  // check if all methods are available after this provider is online\n  const isAllMethodsAvailable: ReturnType<\n    typeof getAllMethodsAvailable\n  > = yield select(getAllMethodsAvailable);\n\n  // if they are, put app in online state\n  if (isAllMethodsAvailable) {\n    yield call(dispatchOnline);\n  } else {\n    yield call(dispatchOffline);\n  }\n}\n\nfunction* handleBalancerHealth() {\n  const chan = yield actionChannel(\n    [\n      PROVIDER_STATS.ONLINE,\n      PROVIDER_STATS.OFFLINE,\n      PROVIDER_STATS.ADDED,\n      PROVIDER_STATS.REMOVED,\n      BALANCER.NETWORK_SWITCH_SUCCEEDED,\n      BALANCER.NETWORK_SWTICH_REQUESTED,\n      BALANCER.AUTO,\n      BALANCER.MANUAL_SUCCEEDED,\n    ],\n    buffers.expanding(50),\n  );\n  while (true) {\n    const action = yield take(chan);\n    yield call(setBalancerOnlineState, action);\n  }\n}\n\nexport const balancerHealthWatcher = [fork(handleBalancerHealth)];\n","import { callMeetsBalancerRetryThreshold } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  IProviderCall,\n  IProviderCallTimeout,\n  PROVIDER_CALL,\n  providerCallFailed,\n  providerCallRequested,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { providerOffline } from '@src/ducks/providerBalancer/providerStats';\nimport { providerExceedsRequestFailureThreshold } from '@src/ducks/selectors';\nimport { createRetryCall } from '@src/saga/sagaUtils';\nimport { put, select, takeEvery } from 'redux-saga/effects';\n\nfunction* handleCallTimeouts(action: IProviderCallTimeout) {\n  const { payload: { error, providerCall } } = action;\n  const { providerId } = providerCall;\n\n  const shouldSetProviderOffline: ReturnType<\n    typeof providerExceedsRequestFailureThreshold\n  > = yield select(providerExceedsRequestFailureThreshold, action);\n\n  if (shouldSetProviderOffline) {\n    yield put(providerOffline({ providerId }));\n  }\n\n  const callFailed: ReturnType<\n    typeof callMeetsBalancerRetryThreshold\n  > = yield select(callMeetsBalancerRetryThreshold, action);\n\n  if (callFailed) {\n    yield put(providerCallFailed({ error: error.message, providerCall }));\n  } else {\n    const nextProviderCall: IProviderCall = createRetryCall(providerCall);\n    yield put(providerCallRequested(nextProviderCall));\n  }\n}\n\nexport const callTimeoutWatcher = [\n  takeEvery(PROVIDER_CALL.TIMEOUT, handleCallTimeouts),\n];\n","import {\n  BALANCER,\n  balancerNetworkSwitchRequested,\n  IBalancerManualRequested,\n  setManualFailed,\n  setManualSucceeded,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { getNetwork } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport { getProviderConfigById } from '@src/ducks/providerConfigs';\nimport { AllActions } from '@src/ducks/types';\nimport { checkProviderConnectivity } from '@src/saga/helpers/connectivity';\nimport { logger } from '@src/utils/logging';\nimport { SagaIterator } from 'redux-saga';\nimport { call, put, select, take, takeEvery } from 'redux-saga/effects';\n\nfunction* attemptManualMode(\n  providerId: string,\n  skipOfflineCheck: boolean,\n): SagaIterator {\n  const config: ReturnType<typeof getProviderConfigById> = yield select(\n    getProviderConfigById,\n    providerId,\n  );\n\n  if (!config) {\n    return yield put(\n      setManualFailed({\n        error: `Provider config for ${providerId} not found`,\n      }),\n    );\n  }\n\n  const isOnline: boolean = yield call(checkProviderConnectivity, providerId);\n\n  if (!isOnline && !skipOfflineCheck) {\n    return yield put(\n      setManualFailed({\n        error: `${providerId} to manually set to is not online`,\n      }),\n    );\n  }\n\n  const network: ReturnType<typeof getNetwork> = yield select(getNetwork);\n\n  if (config.network !== network) {\n    logger.log(`Manually set provider ${providerId} has a different network\n      (Provider network: ${config.network}, current network ${network}).\n       Setting new network`);\n    const requestAction = balancerNetworkSwitchRequested({\n      network: config.network,\n    });\n    yield put(requestAction);\n    yield take((action: AllActions) => {\n      if (action.type === BALANCER.NETWORK_SWITCH_SUCCEEDED) {\n        return action.meta.id === requestAction.meta.id;\n      }\n      return false;\n    });\n  }\n\n  yield put(setManualSucceeded({ providerId }));\n}\n\nfunction* handleManualMode({\n  payload: { providerId, skipOfflineCheck },\n}: IBalancerManualRequested): SagaIterator {\n  yield call(attemptManualMode, providerId, skipOfflineCheck);\n}\n\nexport const manualModeWatcher = [\n  takeEvery(BALANCER.MANUAL_REQUESTED, handleManualMode),\n];\n","import { ProcessedProvider } from '@src/ducks/providerBalancer/providerStats';\nimport { getAllProvidersOfNetwork } from '@src/ducks/selectors';\nimport { processProvider } from '@src/saga/helpers/processing';\nimport { reduceProcessedProviders } from '@src/saga/sagaUtils';\nimport { all, call, select } from 'redux-saga/effects';\n\n/**\n * @description Gets all of the providers of the requested next network,\n * then creates all of the workers and provider statistics required for a successful switch\n * @param network\n */\nexport function* initializeNewNetworkProviders(network: string) {\n  const providers: ReturnType<typeof getAllProvidersOfNetwork> = yield select(\n    getAllProvidersOfNetwork,\n    network,\n  );\n\n  const providerEntries = Object.entries(providers).map(\n    ([providerId, providerConfig]) =>\n      call(processProvider, providerId, providerConfig),\n  );\n\n  // process adding all providers in parallel\n  const processedProviders: ProcessedProvider[] = yield all(providerEntries);\n  const networkSwitchPayload = reduceProcessedProviders(\n    processedProviders,\n    network,\n  );\n\n  return networkSwitchPayload;\n}\n","import {\n  BALANCER,\n  balancerNetworkSwitchSucceeded,\n  IBalancerInit,\n  IBalancerNetworkSwitchRequested,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { logger } from '@src/utils/logging';\nimport { buffers, SagaIterator } from 'redux-saga';\nimport { actionChannel, call, fork, put, take } from 'redux-saga/effects';\nimport { initializeNewNetworkProviders } from './helpers';\n\nfunction* handleNetworkSwitch({\n  payload,\n  meta,\n}: IBalancerNetworkSwitchRequested | IBalancerInit): SagaIterator {\n  const networkSwitchPayload = yield call(\n    initializeNewNetworkProviders,\n    payload.network,\n  );\n  logger.log(`Network switch to ${payload.network} succeeded`);\n\n  yield put(balancerNetworkSwitchSucceeded(networkSwitchPayload, meta.id));\n}\n\nfunction* networkSwitchActionChannel() {\n  const chan = yield actionChannel(\n    [BALANCER.NETWORK_SWTICH_REQUESTED, BALANCER.INIT],\n    buffers.expanding(50),\n  );\n  while (true) {\n    const action: IBalancerNetworkSwitchRequested | IBalancerInit = yield take(\n      chan,\n    );\n    logger.log(`Taking action ${JSON.stringify(action, null, 1)}`);\n    yield call(handleNetworkSwitch, action);\n  }\n}\n\n// we dont use takeevery here to avoid processing two switch requests at the same time\nexport const watchNetworkSwitches = [fork(networkSwitchActionChannel)];\n","import {\n  BALANCER,\n  balancerQueueTimeout,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport {\n  getQueueTimeout,\n  isOffline,\n} from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  IProviderCallRequested,\n  providerCallFailed,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { getAvailableProviderId } from '@src/ducks/selectors';\nimport { balancerChannel, providerChannels } from '@src/saga/channels';\nimport { delay, SagaIterator } from 'redux-saga';\nimport { apply, call, fork, put, race, select, take } from 'redux-saga/effects';\n\nfunction* getOptimalProviderId(\n  payload: IProviderCallRequested['payload'],\n): SagaIterator {\n  // check if the app is offline\n  if (yield select(isOffline)) {\n    yield take(BALANCER.ONLINE); // wait until its back online\n  }\n\n  // get an available providerId to put the action to the channel\n  const providerId: ReturnType<typeof getAvailableProviderId> = yield select(\n    getAvailableProviderId,\n    payload,\n  );\n\n  if (!providerId) {\n    // TODO: seperate this into a different action\n    const action = providerCallFailed({\n      providerCall: { ...payload, providerId: 'SHEPHERD' },\n      error: 'No available provider found',\n    });\n    yield put(action);\n    return undefined;\n  }\n\n  return providerId;\n}\n\nfunction* handleRequest(): SagaIterator {\n  yield apply(balancerChannel, balancerChannel.init);\n\n  while (true) {\n    // test if this starts queue timeout\n    const action: IProviderCallRequested = yield apply(\n      balancerChannel,\n      balancerChannel.take,\n    );\n\n    function* process() {\n      if (!action) {\n        return;\n      }\n      const { payload } = action;\n      const providerId: string | undefined = yield call(\n        getOptimalProviderId,\n        payload,\n      );\n\n      if (providerId) {\n        yield apply(providerChannels, providerChannels.put, [\n          providerId,\n          action,\n        ]);\n      }\n    }\n\n    const queueTimeoutMs: ReturnType<typeof getQueueTimeout> = yield select(\n      getQueueTimeout,\n    );\n\n    const { queueTimeout } = yield race({\n      processed: call(process),\n      // we cancel in case of a balancer flush\n      // so we dont put an action that's about to be flushed\n      // to a worker\n      networkSwitch: take(BALANCER.FLUSH),\n      queueTimeout: call(delay, queueTimeoutMs),\n    });\n\n    if (queueTimeout) {\n      console.error('Queue timeout');\n      yield put(balancerQueueTimeout());\n    }\n  }\n}\n\nexport const providerRequestWatcher = [fork(handleRequest)];\n","import { BALANCER } from '@src/ducks/providerBalancer/balancerConfig';\nimport {\n  getProviderStatsById,\n  PROVIDER_STATS,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { checkProviderConnectivity } from '@src/saga/helpers/connectivity';\nimport { delay, SagaIterator } from 'redux-saga';\nimport { call, select, take } from 'redux-saga/effects';\n\nexport function* pollProviderUntilConnected(providerId: string): SagaIterator {\n  while (true) {\n    yield call(delay, 5000);\n\n    const connected: boolean = yield call(\n      checkProviderConnectivity,\n      providerId,\n    );\n    if (connected) {\n      return true;\n    }\n  }\n}\n\n/**\n * @description waits for any action that adds to the provider stats reducer,\n * and only returns when the specified provider exists\n * @param providerId\n */\nexport function* waitForProviderStatsToExist(providerId: string) {\n  while (true) {\n    const stats: ReturnType<typeof getProviderStatsById> = yield select(\n      getProviderStatsById,\n      providerId,\n    );\n    if (stats) {\n      return true;\n    }\n    yield take([BALANCER.NETWORK_SWITCH_SUCCEEDED, PROVIDER_STATS.ADDED]);\n  }\n}\n","import { BALANCER } from '@src/ducks/providerBalancer/balancerConfig';\nimport {\n  IProviderStatsOffline,\n  PROVIDER_STATS,\n  providerOnline,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { call, put, race, take, takeEvery } from 'redux-saga/effects';\nimport {\n  pollProviderUntilConnected,\n  waitForProviderStatsToExist,\n} from './helpers';\n\nfunction* watchOfflineProvider({\n  payload: { providerId },\n}: IProviderStatsOffline) {\n  yield call(pollProviderUntilConnected, providerId);\n  // handles failure case of:\n  // network switch requested\n  // provider isnt online so this fires\n  // provider is online before network switch is successful\n  // this puts an action to a non existent provider id\n  yield call(waitForProviderStatsToExist, providerId);\n  yield put(providerOnline({ providerId }));\n  return true;\n}\n\nfunction* handleWatching(action: IProviderStatsOffline) {\n  yield race({\n    online: call(watchOfflineProvider, action),\n    networkSwitched: take(BALANCER.NETWORK_SWTICH_REQUESTED),\n  });\n}\n\nexport const providerHealthWatcher = [\n  takeEvery(PROVIDER_STATS.OFFLINE, handleWatching),\n];\n","import { subscriptionWatcher } from './watchActionSubscription';\nimport { addProviderConfigWatcher } from './watchAddingProviders';\nimport { balancerFlushWatcher } from './watchBalancerFlush';\nimport { balancerHealthWatcher } from './watchBalancerHealth';\nimport { callTimeoutWatcher } from './watchCallTimeouts';\nimport { manualModeWatcher } from './watchManualMode';\nimport { watchNetworkSwitches } from './watchNetworkSwitches';\nimport { providerRequestWatcher } from './watchProviderCalls';\nimport { providerHealthWatcher } from './watchProviderHealth';\n\nexport const watchers = [\n  ...watchNetworkSwitches,\n\n  ...subscriptionWatcher,\n  ...addProviderConfigWatcher,\n  ...balancerFlushWatcher,\n  ...callTimeoutWatcher,\n  ...providerRequestWatcher,\n  ...providerHealthWatcher,\n  ...balancerHealthWatcher,\n  ...manualModeWatcher,\n];\n","import { watchers } from '@src/saga/watchers';\nimport { all } from 'redux-saga/effects';\n\nexport function* providerBalancer() {\n  yield all(watchers);\n}\n","import { filterMiddlware } from '@src/ducks/middleware';\nimport {\n  providerBalancer,\n  providerBalancerSelectors,\n} from '@src/ducks/providerBalancer';\nimport { providerConfigs } from '@src/ducks/providerConfigs';\nimport * as providerConfigsSelectors from '@src/ducks/providerConfigs/selectors';\nimport { storeManager } from '@src/ducks/store';\nimport { RootState } from '@src/types';\nimport { applyMiddleware, combineReducers, createStore } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport { composeWithDevTools } from 'remote-redux-devtools';\nimport { providerBalancer as providerBalancerSaga } from '../saga';\nimport * as rootSelectors from './selectors';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst composeEnhancers = composeWithDevTools({\n  realtime: true,\n  port: 8000,\n  maxAge: 300,\n});\n\nconst rootReducer = combineReducers<RootState>({\n  providerBalancer,\n  providerConfigs,\n});\n\nconst middleware = process.env.DEV_TOOLS\n  ? composeEnhancers(applyMiddleware(sagaMiddleware, filterMiddlware))\n  : applyMiddleware(sagaMiddleware, filterMiddlware);\n\nconst store = createStore<RootState>(rootReducer, middleware);\nstoreManager.setStore(store);\n\nconst INITIAL_ROOT_STATE = rootReducer(undefined as any, {} as any);\n\nsagaMiddleware.run(providerBalancerSaga);\n\nconst selectors = {\n  rootSelectors,\n  providerBalancerSelectors,\n  providerConfigsSelectors,\n};\n\nexport {\n  filterMiddlware as shepherdMiddlware,\n  providerBalancerSaga,\n  rootReducer,\n  store,\n  INITIAL_ROOT_STATE,\n  selectors,\n};\n"],"names":["INITIAL_STATE","handleNetworkSwitch","handleWorkerKilled","handleWorkerSpawned","handleProviderAdded","handleProviderCallTimeout","handleProviderCallSucceeded","handleWorkerProcessing","providerBalancer","providerBalancerSaga"],"mappings":"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"}