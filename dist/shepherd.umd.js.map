{"version":3,"file":"shepherd.umd.js","sources":["../src/utils/idGenerator.ts","../src/ducks/providerBalancer/balancerConfig/types.ts","../src/ducks/providerBalancer/balancerConfig/actions.ts","../src/ducks/providerBalancer/balancerConfig/reducer.ts","../src/utils/logging.ts","../src/ducks/store.ts","../src/ducks/rootState.ts","../src/ducks/providerBalancer/selectors.ts","../src/ducks/providerBalancer/balancerConfig/selectors.ts","../src/ducks/providerBalancer/providerCalls/types.ts","../src/ducks/providerBalancer/providerCalls/actions.ts","../src/ducks/providerBalancer/providerCalls/selectors.ts","../src/ducks/providerBalancer/workers/types.ts","../src/ducks/providerBalancer/workers/actions.ts","../src/ducks/providerBalancer/workers/selectors.ts","../src/ducks/providerBalancer/providerStats/types.ts","../src/ducks/providerBalancer/providerStats/actions.ts","../src/ducks/providerBalancer/providerStats/selectors.ts","../src/ducks/providerBalancer/providerStats/reducer.ts","../src/ducks/providerBalancer/workers/reducer.ts","../src/ducks/providerBalancer/providerCalls/reducer.ts","../src/ducks/subscribe/types.ts","../src/ducks/subscribe/actions.ts","../src/ducks/subscribe/utils.ts","../src/ducks/providerConfigs/types.ts","../src/ducks/providerConfigs/reducer.ts","../src/ducks/providerConfigs/actions.ts","../src/utils/ethUnits.ts","../src/validators/index.ts","../src/providers/rpc/client.ts","../src/providers/rpc/requests.ts","../src/providers/rpc/index.ts","../src/providers/custom/index.ts","../src/providers/etherscan/client.ts","../src/providers/etherscan/requests.ts","../src/providers/etherscan/index.ts","../src/providers/infura/client.ts","../src/providers/infura/index.ts","../src/providers/web3/client.ts","../src/providers/web3/requests.ts","../src/providers/web3/index.ts","../src/providers/providerStorage.ts","../src/ducks/providerConfigs/selectors.ts","../src/providers/providerManager.ts","../src/providers/constants.ts","../src/providers/providerProxy.ts","../src/api.ts","../src/ducks/middleware.ts","../src/ducks/providerBalancer/index.ts","../src/saga/watchers/watchActionSubscription.ts","../src/saga/sagaUtils.ts","../src/saga/channels/base.ts","../src/saga/channels/balancerChannel.ts","../src/saga/channels/providerChannel.ts","../src/saga/channels/providerChannels.ts","../src/saga/channels/index.ts","../src/saga/workers/helpers.ts","../src/saga/workers/index.ts","../src/saga/helpers/connectivity.ts","../src/saga/helpers/processing.ts","../src/saga/watchers/watchAddingProviders.ts","../src/saga/watchers/watchBalancerFlush.ts","../src/ducks/utils.ts","../src/ducks/selectors.ts","../src/saga/watchers/watchBalancerHealth.ts","../src/saga/watchers/watchCallTimeouts.ts","../src/saga/watchers/watchManualMode.ts","../src/saga/watchers/watchNetworkSwitches/helpers.ts","../src/saga/watchers/watchNetworkSwitches/index.ts","../src/saga/watchers/watchProviderCalls.ts","../src/saga/watchers/watchProviderHealth/helpers.ts","../src/saga/watchers/watchProviderHealth/index.ts","../src/saga/watchers/index.ts","../src/saga/index.ts","../src/ducks/index.ts"],"sourcesContent":["export const idGeneratorFactory = () => {\n  let callId = 0;\n  return () => {\n    const currValue = callId;\n    callId += 1;\n    return currValue;\n  };\n};\n","import { IProviderBalancerState } from '@src/ducks/providerBalancer';\n\nexport enum BALANCER {\n  NETWORK_SWTICH_REQUESTED = 'BALANCER_NETWORK_SWTICH_REQUESTED',\n  NETWORK_SWITCH_SUCCEEDED = 'BALANCER_NETWORK_SWITCH_SUCCEEDED',\n  SET_PROVIDER_CALL_RETRY_THRESHOLD = 'BALANCER_SET_PROVIDER_CALL_RETRY_THRESHOLD',\n  INIT = 'BALANCER_INIT',\n  FLUSH = 'BALANCER_FLUSH',\n  AUTO = 'BALANCER_AUTO',\n  MANUAL_REQUESTED = 'BALANCER_MANUAL_REQUESTED',\n  MANUAL_SUCCEEDED = 'BALANCER_MANUAL_SUCCEEDED',\n  MANUAL_FAILED = 'BALANCER_MANUAL_FAILED',\n\n  OFFLINE = 'BALANCER_OFFLINE',\n  ONLINE = 'BALANCER_ONLINE',\n  QUEUE_TIMEOUT = 'QUEUE_TIMEOUT',\n}\n\nexport type BalancerConfigInitConfig = Partial<{\n  providerCallRetryThreshold: number;\n  network: string;\n  queueTimeout: number;\n}>;\n\nexport interface IBalancerConfigState {\n  network: string;\n  manual: false | string;\n  offline: boolean;\n  queueTimeout: number;\n  providerCallRetryThreshold: number;\n  networkSwitchPending: boolean;\n}\n\nexport interface IBalancerInit {\n  type: BALANCER.INIT;\n  payload: BalancerConfigInitConfig;\n  meta: { id: number };\n}\n\nexport interface IBalancerFlush {\n  type: BALANCER.FLUSH;\n}\n\nexport interface IBalancerQueueTimeout {\n  type: BALANCER.QUEUE_TIMEOUT;\n}\n\nexport interface IBalancerNetworkSwitchRequested {\n  type: BALANCER.NETWORK_SWTICH_REQUESTED;\n  payload: { network: string };\n  meta: { id: number };\n}\n\nexport interface IBalancerNetworkSwitchSucceeded {\n  type: BALANCER.NETWORK_SWITCH_SUCCEEDED;\n  payload: {\n    providerStats: IProviderBalancerState['providerStats'];\n    workers: IProviderBalancerState['workers'];\n    network: string;\n  };\n  meta: { id: number };\n}\n\nexport interface IBalancerSetProviderCallRetryThreshold {\n  type: BALANCER.SET_PROVIDER_CALL_RETRY_THRESHOLD;\n  payload: {\n    threshold: number;\n  };\n}\n\nexport interface IBalancerOffline {\n  type: BALANCER.OFFLINE;\n}\n\nexport interface IBalancerOnline {\n  type: BALANCER.ONLINE;\n}\n\nexport interface IBalancerAuto {\n  type: BALANCER.AUTO;\n}\n\nexport interface IBalancerManualRequested {\n  type: BALANCER.MANUAL_REQUESTED;\n  payload: { providerId: string; skipOfflineCheck: boolean };\n}\n\nexport interface IBalancerManualSucceeded {\n  type: BALANCER.MANUAL_SUCCEEDED;\n  payload: { providerId: string };\n}\n\nexport interface IBalancerManualFailed {\n  type: BALANCER.MANUAL_FAILED;\n  payload: { error: string };\n}\n\nexport type BalancerAction =\n  | IBalancerInit\n  | IBalancerOffline\n  | IBalancerOnline\n  | IBalancerFlush\n  | IBalancerSetProviderCallRetryThreshold\n  | IBalancerAuto\n  | IBalancerManualRequested\n  | IBalancerManualSucceeded\n  | IBalancerManualFailed\n  | IBalancerNetworkSwitchRequested\n  | IBalancerNetworkSwitchSucceeded;\n","import { idGeneratorFactory } from '@src/utils/idGenerator';\nimport {\n  BALANCER,\n  IBalancerAuto,\n  IBalancerFlush,\n  IBalancerInit,\n  IBalancerManualFailed,\n  IBalancerManualRequested,\n  IBalancerManualSucceeded,\n  IBalancerNetworkSwitchRequested,\n  IBalancerNetworkSwitchSucceeded,\n  IBalancerOffline,\n  IBalancerOnline,\n  IBalancerQueueTimeout,\n  IBalancerSetProviderCallRetryThreshold,\n} from './types';\n\nexport const balancerFlush = (): IBalancerFlush => ({\n  type: BALANCER.FLUSH,\n});\n\nconst networkIdGenerator = idGeneratorFactory();\nexport const balancerNetworkSwitchRequested = (\n  payload: IBalancerNetworkSwitchRequested['payload'],\n): IBalancerNetworkSwitchRequested => ({\n  payload,\n  type: BALANCER.NETWORK_SWTICH_REQUESTED,\n  meta: { id: networkIdGenerator() },\n});\n\nexport const balancerNetworkSwitchSucceeded = (\n  payload: IBalancerNetworkSwitchSucceeded['payload'],\n  id: number,\n): IBalancerNetworkSwitchSucceeded => ({\n  type: BALANCER.NETWORK_SWITCH_SUCCEEDED,\n  payload,\n  meta: { id },\n});\n\nexport const balancerSetProviderCallRetryThreshold = (\n  payload: IBalancerSetProviderCallRetryThreshold['payload'],\n): IBalancerSetProviderCallRetryThreshold => ({\n  type: BALANCER.SET_PROVIDER_CALL_RETRY_THRESHOLD,\n  payload,\n});\n\nexport const balancerInit = (\n  payload: IBalancerInit['payload'],\n): IBalancerInit => ({\n  type: BALANCER.INIT,\n  payload,\n  meta: { id: networkIdGenerator() },\n});\n\nexport const setOffline = (): IBalancerOffline => ({\n  type: BALANCER.OFFLINE,\n});\n\nexport const setOnline = (): IBalancerOnline => ({\n  type: BALANCER.ONLINE,\n});\n\nexport const setAuto = (): IBalancerAuto => ({ type: BALANCER.AUTO });\n\nexport const setManualRequested = (\n  payload: IBalancerManualRequested['payload'],\n): IBalancerManualRequested => ({\n  type: BALANCER.MANUAL_REQUESTED,\n  payload,\n});\n\nexport const setManualSucceeded = (\n  payload: IBalancerManualSucceeded['payload'],\n): IBalancerManualSucceeded => ({\n  type: BALANCER.MANUAL_SUCCEEDED,\n  payload,\n});\n\nexport const setManualFailed = (\n  payload: IBalancerManualFailed['payload'],\n): IBalancerManualFailed => ({\n  type: BALANCER.MANUAL_FAILED,\n  payload,\n});\n\nexport const balancerQueueTimeout = (): IBalancerQueueTimeout => ({\n  type: BALANCER.QUEUE_TIMEOUT,\n});\n","import { IBalancerManualSucceeded } from '@src/ducks/providerBalancer/balancerConfig';\nimport { Reducer } from 'redux';\nimport {\n  BALANCER,\n  BalancerAction,\n  IBalancerAuto,\n  IBalancerConfigState,\n} from './types';\n\nconst INITIAL_STATE: IBalancerConfigState = {\n  manual: false,\n  offline: true,\n  network: 'ETH',\n  providerCallRetryThreshold: 3,\n  networkSwitchPending: false,\n  queueTimeout: 5000,\n};\n\nconst handleBalancerAuto: Reducer<IBalancerConfigState> = (\n  state: IBalancerConfigState,\n  _: IBalancerAuto,\n) => ({\n  ...state,\n  manual: false,\n});\n\nconst handleBalancerManual: Reducer<IBalancerConfigState> = (\n  state: IBalancerConfigState,\n  { payload }: IBalancerManualSucceeded,\n) => ({\n  ...state,\n  manual: payload.providerId,\n});\n\nexport const balancerConfigReducer: Reducer<IBalancerConfigState> = (\n  state: IBalancerConfigState = INITIAL_STATE,\n  action: BalancerAction,\n): IBalancerConfigState => {\n  switch (action.type) {\n    case BALANCER.INIT:\n      return { ...state, ...action.payload };\n    case BALANCER.AUTO:\n      return handleBalancerAuto(state, action);\n    case BALANCER.MANUAL_SUCCEEDED:\n      return handleBalancerManual(state, action);\n    case BALANCER.OFFLINE:\n      return { ...state, offline: true };\n    case BALANCER.ONLINE:\n      return { ...state, offline: false };\n    case BALANCER.NETWORK_SWITCH_SUCCEEDED:\n      return {\n        ...state,\n        network: action.payload.network,\n        networkSwitchPending: false,\n      };\n    case BALANCER.NETWORK_SWTICH_REQUESTED:\n      return { ...state, networkSwitchPending: true };\n    case BALANCER.SET_PROVIDER_CALL_RETRY_THRESHOLD:\n      return {\n        ...state,\n        providerCallRetryThreshold: action.payload.threshold,\n      };\n    default:\n      return state;\n  }\n};\n","class Logger {\n  private shouldLog: boolean = false;\n\n  public enableLogging() {\n    this.shouldLog = true;\n  }\n  public log(...args: any[]) {\n    if (!this.shouldLog) {\n      return;\n    }\n    console.log(...args);\n  }\n}\n\nexport const logger = new Logger();\n","import { logger } from '@src/utils/logging';\nimport { Store } from 'redux';\n\nclass StoreManager {\n  private store: Store<any> | undefined;\n  private root: string | undefined;\n\n  public setRoot(r: string) {\n    logger.log(`Setting root to: ${r}`);\n    this.root = r;\n  }\n\n  public getRoot() {\n    return this.root;\n  }\n\n  public setStore(s: Store<any>) {\n    this.store = s;\n  }\n\n  public getStore() {\n    if (!this.store) {\n      throw Error('no store');\n    }\n    return this.store;\n  }\n}\n\nexport const storeManager = new StoreManager();\n","import { storeManager } from '@src/ducks/store';\nimport { RootState } from '@src/types';\n\nexport const getRootState = (s: any): RootState => {\n  const customRoot = storeManager.getRoot();\n  return customRoot ? s[customRoot] : s;\n};\n","import { getRootState } from '@src/ducks/rootState';\nimport { RootState } from '@src/types';\n\nexport const getProviderBalancer = (state: RootState) =>\n  getRootState(state).providerBalancer;\n","import { IProviderCallTimeout } from '@src/ducks/providerBalancer/providerCalls';\nimport { getProviderBalancer } from '@src/ducks/providerBalancer/selectors';\nimport { RootState } from '@src/types';\n\nexport const getBalancerConfig = (state: RootState) =>\n  getProviderBalancer(state).balancerConfig;\n\nexport const getQueueTimeout = (state: RootState) =>\n  getBalancerConfig(state).queueTimeout;\n\nexport const getManualMode = (state: RootState) =>\n  getBalancerConfig(state).manual;\n\nexport const isOffline = (state: RootState) => getBalancerConfig(state).offline;\n\nexport const getNetwork = (state: RootState) =>\n  getBalancerConfig(state).network;\n\nexport const getProviderCallRetryThreshold = (state: RootState) =>\n  getBalancerConfig(state).providerCallRetryThreshold;\n\nexport const isSwitchingNetworks = (state: RootState) =>\n  getBalancerConfig(state).networkSwitchPending;\n\nexport const callMeetsBalancerRetryThreshold = (\n  state: RootState,\n  { payload: { providerCall } }: IProviderCallTimeout,\n) => {\n  const providerCallRetryThreshold = getProviderCallRetryThreshold(state);\n\n  // checks the current call to see if it has failed more than the configured number\n  return providerCall.numOfRetries >= providerCallRetryThreshold;\n};\n","import { AllProviderMethods, StrIdx } from '@src/types';\n\nexport type ProviderCallState =\n  | ISuccessfulProviderCall\n  | IPendingProviderCall\n  | IFailedProviderCall;\n\nexport type ProviderCallsState = StrIdx<ProviderCallState>;\n\nexport enum PROVIDER_CALL {\n  REQUESTED = 'PROVIDER_CALL_REQUESTED',\n  TIMEOUT = 'PROVIDER_CALL_TIMEOUT',\n  SUCCEEDED = 'PROVIDER_CALL_SUCCEEDED',\n  FAILED = 'PROVIDER_CALL_FAILED',\n  FLUSHED = 'PROVIDER_CALL_FLUSHED',\n}\n\nexport interface IProviderCall {\n  callId: number;\n  rpcMethod: AllProviderMethods;\n  rpcArgs: string[];\n  numOfRetries: number;\n  minPriorityProviderList: string[];\n  providerWhiteList?: string[];\n  providerId?: string;\n}\n\nexport type ProviderCallWithPid = IProviderCall & { providerId: string };\n\nexport interface ISuccessfulProviderCall extends IProviderCall {\n  result: string;\n  error: null;\n  pending: false;\n}\n\nexport interface IFailedProviderCall extends ProviderCallWithPid {\n  result: null;\n  error: string;\n  pending: false;\n}\n\nexport interface IFlushedProviderCall extends IProviderCall {\n  result: null;\n  error: string;\n  pending: false;\n}\n\nexport interface IPendingProviderCall extends IProviderCall {\n  result: null;\n  error: null;\n  pending: true;\n}\n\nexport interface IProviderCallRequested {\n  type: PROVIDER_CALL.REQUESTED;\n  payload: IProviderCall;\n}\n\nexport interface IProviderCallTimeout {\n  type: PROVIDER_CALL.TIMEOUT;\n  payload: { error: Error; providerCall: ProviderCallWithPid };\n}\n\nexport interface IProviderCallFailed {\n  type: PROVIDER_CALL.FAILED;\n  payload: { error: string; providerCall: ProviderCallWithPid };\n}\n\nexport interface IProviderCallFlushed {\n  type: PROVIDER_CALL.FLUSHED;\n  payload: { error: string; providerCall: IProviderCall };\n}\n\nexport interface IProviderCallSucceeded {\n  type: PROVIDER_CALL.SUCCEEDED;\n  payload: { result: string; providerCall: ProviderCallWithPid };\n}\n\nexport type ProviderCallAction =\n  | IProviderCallRequested\n  | IProviderCallTimeout\n  | IProviderCallFailed\n  | IProviderCallSucceeded\n  | IProviderCallFlushed;\n","import {\n  IProviderCallFailed,\n  IProviderCallFlushed,\n  IProviderCallRequested,\n  IProviderCallSucceeded,\n  IProviderCallTimeout,\n  PROVIDER_CALL,\n} from './types';\n\nexport const providerCallRequested = (\n  payload: IProviderCallRequested['payload'],\n): IProviderCallRequested => ({\n  type: PROVIDER_CALL.REQUESTED,\n  payload,\n});\n\nexport const providerCallTimeout = (\n  payload: IProviderCallTimeout['payload'],\n): IProviderCallTimeout => ({\n  type: PROVIDER_CALL.TIMEOUT,\n  payload,\n});\n\nexport const providerCallFailed = (\n  payload: IProviderCallFailed['payload'],\n): IProviderCallFailed => ({\n  type: PROVIDER_CALL.FAILED,\n  payload,\n});\n\nexport const providerCallFlushed = (\n  payload: IProviderCallFlushed['payload'],\n): IProviderCallFlushed => ({ type: PROVIDER_CALL.FLUSHED, payload });\n\nexport const providerCallSucceeded = (\n  payload: IProviderCallSucceeded['payload'],\n): IProviderCallSucceeded => ({\n  type: PROVIDER_CALL.SUCCEEDED,\n  payload,\n});\n","import { IPendingProviderCall } from '@src/ducks/providerBalancer/providerCalls';\nimport { getProviderBalancer } from '@src/ducks/providerBalancer/selectors';\nimport { RootState } from '@src/types';\n\nexport const getProviderCalls = (state: RootState) =>\n  getProviderBalancer(state).providerCalls;\n\nexport const getProviderCallById = (state: RootState, id: number) =>\n  getProviderCalls(state)[id];\n\nexport const isStaleCall = (state: RootState, callId: number) => {\n  const call = getProviderCallById(state, callId);\n  return !call || !call.pending;\n};\n\nexport const getPendingProviderCallsByProviderId = (\n  state: RootState,\n  providerId: string,\n) => {\n  const pendingCalls = getAllPendingCalls(state);\n  const pendingCallsByProviderId = pendingCalls.filter(\n    providerCall =>\n      providerCall.providerId && providerCall.providerId === providerId,\n  );\n  return pendingCallsByProviderId.length;\n};\n\nexport const getAllPendingCalls = (\n  state: RootState,\n): IPendingProviderCall[] => {\n  const providerCalls = getProviderCalls(state);\n  const providerCallsArr = Object.values(providerCalls);\n  const pendingCalls: IPendingProviderCall[] = providerCallsArr.filter(\n    (providerCall): providerCall is IPendingProviderCall => {\n      if (providerCall.pending) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n  );\n  return pendingCalls;\n};\n","import { ProviderCallWithPid } from '@src/ducks/providerBalancer/providerCalls';\nimport { Task } from 'redux-saga';\nimport { IProviderCall } from '../providerCalls';\n\nexport interface IWorker {\n  task: Task;\n  assignedProvider: string;\n  currentPayload: IProviderCall | null;\n}\n\nexport interface IWorkerState {\n  [workerId: string]: Readonly<IWorker>;\n}\n\nexport enum WORKER {\n  PROCESSING = 'WORKER_PROCESSING',\n  SPAWNED = 'WORKER_SPAWNED',\n  KILLED = 'WORKER_KILLED',\n}\n\nexport interface IWorkerSpawned {\n  type: WORKER.SPAWNED;\n  payload: {\n    providerId: string;\n    workerId: string;\n    task: Task;\n  };\n}\n\nexport interface IWorkerProcessing {\n  type: WORKER.PROCESSING;\n  payload: {\n    workerId: string;\n    currentPayload: ProviderCallWithPid;\n  };\n}\n\nexport interface IWorkerKilled {\n  type: WORKER.KILLED;\n  payload: {\n    providerId: string;\n    workerId: string;\n    error: Error;\n  };\n}\n\nexport type WorkerAction = IWorkerSpawned | IWorkerProcessing | IWorkerKilled;\n","import {\n  IWorkerKilled,\n  IWorkerProcessing,\n  IWorkerSpawned,\n  WORKER,\n} from './types';\n\nexport const workerSpawned = (\n  payload: IWorkerSpawned['payload'],\n): IWorkerSpawned => ({\n  type: WORKER.SPAWNED,\n  payload,\n});\n\nexport const workerProcessing = (\n  payload: IWorkerProcessing['payload'],\n): IWorkerProcessing => ({\n  type: WORKER.PROCESSING,\n  payload,\n});\n\nexport const workerKilled = (\n  payload: IWorkerKilled['payload'],\n): IWorkerKilled => ({\n  type: WORKER.KILLED,\n  payload,\n});\n","import { getProviderBalancer } from '@src/ducks/providerBalancer/selectors';\nimport { RootState } from '@src/types';\n\nexport const getWorkers = (state: RootState) =>\n  getProviderBalancer(state).workers;\n\nexport const getWorkerById = (state: RootState, id: string) =>\n  getWorkers(state)[id];\n","import { IWorker } from '@src/ducks/providerBalancer/workers';\nimport { StrIdx } from '@src/types';\n\nexport interface IProviderStats {\n  currWorkersById: string[];\n  isOffline: boolean;\n  requestFailures: number;\n  avgResponseTime: number;\n}\n\nexport interface IProviderStatsState {\n  [providerId: string]: Readonly<IProviderStats>;\n}\n\nexport enum PROVIDER_STATS {\n  ONLINE = 'PROVIDER_STATS_ONLINE',\n  OFFLINE = 'PROVIDER_STATS_OFFLINE',\n  ADDED = 'PROVIDER_STATS_ADDED',\n  REMOVED = 'PROVIDER_STATS_REMOVED',\n}\n\nexport interface IProviderStatsOnline {\n  type: PROVIDER_STATS.ONLINE;\n  payload: {\n    providerId: string;\n  };\n}\n\nexport interface IProviderStatsOffline {\n  type: PROVIDER_STATS.OFFLINE;\n  payload: {\n    providerId: string;\n  };\n}\n\nexport interface IProviderStatsAdded {\n  type: PROVIDER_STATS.ADDED;\n  payload: {\n    providerId: string;\n    stats: IProviderStats;\n    workers: StrIdx<IWorker>;\n  };\n}\n\nexport type ProcessedProvider = IProviderStatsAdded['payload'];\n\nexport interface IProviderStatsRemoved {\n  type: PROVIDER_STATS.REMOVED;\n  payload: { providerId: string };\n}\n\nexport type ProviderStatsAction =\n  | IProviderStatsOnline\n  | IProviderStatsOffline\n  | IProviderStatsAdded\n  | IProviderStatsRemoved;\n","import {\n  IProviderStatsAdded,\n  IProviderStatsOffline,\n  IProviderStatsOnline,\n  IProviderStatsRemoved,\n  PROVIDER_STATS,\n} from './types';\n\nexport const providerOnline = (\n  payload: IProviderStatsOnline['payload'],\n): IProviderStatsOnline => ({\n  type: PROVIDER_STATS.ONLINE,\n  payload,\n});\n\nexport const providerOffline = (\n  payload: IProviderStatsOffline['payload'],\n): IProviderStatsOffline => ({\n  type: PROVIDER_STATS.OFFLINE,\n  payload,\n});\n\nexport const providerAdded = (\n  payload: IProviderStatsAdded['payload'],\n): IProviderStatsAdded => ({\n  type: PROVIDER_STATS.ADDED,\n  payload,\n});\n\nexport const providerRemoved = (\n  payload: IProviderStatsRemoved['payload'],\n): IProviderStatsRemoved => ({\n  type: PROVIDER_STATS.REMOVED,\n  payload,\n});\n","import {\n  IProviderStats,\n  IProviderStatsState,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { getProviderBalancer } from '@src/ducks/providerBalancer/selectors';\nimport { RootState } from '@src/types';\n\nexport const getProviderStats = (state: RootState) =>\n  getProviderBalancer(state).providerStats;\n\nexport const getProviderStatsById = (\n  state: RootState,\n  id: string,\n): Readonly<IProviderStats> | null => getProviderStats(state)[id];\n\nexport type OnlineProviders = {\n  [providerId in keyof IProviderStatsState]: IProviderStatsState[providerId] & {\n    isOffline: false;\n  }\n};\n\n/**\n * @description an available provider === it being online\n * @param state\n */\nexport const getOnlineProviders = (state: RootState): OnlineProviders => {\n  const providers = getProviderStats(state);\n  const initialState: OnlineProviders = {};\n\n  const isOnline = (\n    provider: IProviderStatsState[string],\n  ): provider is OnlineProviders[string] => !provider.isOffline;\n\n  return Object.entries(providers).reduce(\n    (accu, [curProviderId, curProvider]) => {\n      if (isOnline(curProvider)) {\n        return { ...accu, [curProviderId]: curProvider };\n      }\n      return accu;\n    },\n    initialState,\n  );\n};\n","import {\n  BALANCER,\n  BalancerAction,\n  IBalancerFlush,\n  IBalancerNetworkSwitchSucceeded,\n} from '../balancerConfig/types';\nimport {\n  IProviderCallTimeout,\n  PROVIDER_CALL,\n  ProviderCallAction,\n} from '../providerCalls/types';\nimport {\n  IWorkerKilled,\n  IWorkerSpawned,\n  WORKER,\n  WorkerAction,\n} from '../workers/types';\nimport {\n  IProviderStatsAdded,\n  IProviderStatsOffline,\n  IProviderStatsOnline,\n  IProviderStatsRemoved,\n  IProviderStatsState,\n  PROVIDER_STATS,\n  ProviderStatsAction,\n} from './types';\n\ntype NReducer<T> = (\n  state: IProviderStatsState,\n  action: T,\n) => IProviderStatsState;\n\nconst INITIAL_STATE: IProviderStatsState = {};\n\nconst handleNetworkSwitch: NReducer<IBalancerNetworkSwitchSucceeded> = (\n  _,\n  { payload: { providerStats } },\n) => {\n  for (const [providerId, provider] of Object.entries(providerStats)) {\n    if (provider.avgResponseTime < 0) {\n      throw Error(`Provider ${providerId} has a response time of below 0`);\n    }\n    if (provider.requestFailures !== 0) {\n      throw Error(`Provider ${providerId} has non-zero request failures`);\n    }\n  }\n\n  return providerStats;\n};\n\nconst handleWorkerKilled: NReducer<IWorkerKilled> = (\n  state,\n  { payload: { providerId, workerId } },\n) => {\n  const providerToChange = state[providerId];\n  if (!providerToChange) {\n    throw Error(`Provider ${providerId} does not exist`);\n  }\n\n  if (!providerToChange.currWorkersById.includes(workerId)) {\n    throw Error(`Worker ${workerId} does not exist`);\n  }\n\n  const nextProviderProviderStatsState = {\n    ...providerToChange,\n    currWorkersById: providerToChange.currWorkersById.filter(\n      id => id !== workerId,\n    ),\n  };\n  return { ...state, [providerId]: nextProviderProviderStatsState };\n};\n\nconst handleWorkerSpawned: NReducer<IWorkerSpawned> = (\n  state,\n  { payload: { providerId, workerId } },\n) => {\n  // check for existence of provider\n  const providerToChange = state[providerId];\n  if (!providerToChange) {\n    throw Error(`Provider ${providerId} does not exist`);\n  }\n\n  // check for duplicates\n  if (providerToChange.currWorkersById.includes(workerId)) {\n    throw Error(`Worker ${workerId} already exists`);\n  }\n\n  const nextProviderProviderStatsState = {\n    ...providerToChange,\n    currWorkersById: [...providerToChange.currWorkersById, workerId],\n  };\n  return { ...state, [providerId]: nextProviderProviderStatsState };\n};\n\nconst handleProviderOnline: NReducer<IProviderStatsOnline> = (\n  state,\n  { payload: { providerId } },\n) => {\n  // check for existence of provider\n  const providerToChange = state[providerId];\n  if (!providerToChange) {\n    throw Error(`Provider ${providerId} does not exist`);\n  }\n\n  return {\n    ...state,\n    [providerId]: {\n      ...providerToChange,\n      isOffline: false,\n    },\n  };\n};\n\nconst handleProviderOffline: NReducer<IProviderStatsOffline> = (\n  state,\n  { payload: { providerId } },\n) => {\n  // check for existence of provider\n  const providerToChange = state[providerId];\n  if (!providerToChange) {\n    // done for initialization phase\n    return state;\n  }\n\n  return {\n    ...state,\n    [providerId]: {\n      ...providerToChange,\n      isOffline: true,\n      requestFailures: 0,\n    },\n  };\n};\n\nconst handleProviderAdded: NReducer<IProviderStatsAdded> = (\n  state: IProviderStatsState,\n  { payload: { providerId, stats } },\n) => {\n  if (state[providerId]) {\n    throw Error(`Provider ${providerId} already exists`);\n  }\n\n  return { ...state, [providerId]: stats };\n};\n\nconst handleProviderRemoved: NReducer<IProviderStatsRemoved> = (\n  state,\n  { payload },\n) => {\n  if (!state[payload.providerId]) {\n    throw Error(`Provider ${payload.providerId} does not exist`);\n  }\n  const stateCopy = { ...state };\n  Reflect.deleteProperty(stateCopy, payload.providerId);\n  return stateCopy;\n};\n\nconst handleProviderCallTimeout: NReducer<IProviderCallTimeout> = (\n  state: IProviderStatsState,\n  { payload: { providerCall: { providerId } } }: IProviderCallTimeout,\n) => {\n  // check for existence of provider\n  const providerToChange = state[providerId];\n  if (!providerToChange) {\n    throw Error(`Provider ${providerId} does not exist`);\n  }\n\n  return {\n    ...state,\n    [providerId]: {\n      ...providerToChange,\n      requestFailures: providerToChange.requestFailures + 1,\n    },\n  };\n};\n\nconst handleBalancerFlush: NReducer<IBalancerFlush> = state =>\n  Object.entries(state).reduce<IProviderStatsState>(\n    (obj, [providerId, stats]) => ({\n      ...obj,\n      [providerId]: { ...stats, requestFailures: 0 },\n    }),\n    {},\n  );\n\nexport const providerStatsReducer: NReducer<\n  ProviderStatsAction | WorkerAction | ProviderCallAction | BalancerAction\n> = (state = INITIAL_STATE, action): IProviderStatsState => {\n  switch (action.type) {\n    case WORKER.KILLED:\n      return handleWorkerKilled(state, action);\n    case WORKER.SPAWNED:\n      return handleWorkerSpawned(state, action);\n    case PROVIDER_STATS.ONLINE:\n      return handleProviderOnline(state, action);\n    case PROVIDER_STATS.OFFLINE:\n      return handleProviderOffline(state, action);\n    case PROVIDER_STATS.ADDED:\n      return handleProviderAdded(state, action);\n    case PROVIDER_STATS.REMOVED:\n      return handleProviderRemoved(state, action);\n    case PROVIDER_CALL.TIMEOUT:\n      return handleProviderCallTimeout(state, action);\n    case BALANCER.FLUSH:\n      return handleBalancerFlush(state, action);\n    case BALANCER.NETWORK_SWITCH_SUCCEEDED:\n      return handleNetworkSwitch(state, action);\n    default:\n      return state;\n  }\n};\n","import {\n  IProviderStatsAdded,\n  PROVIDER_STATS,\n  ProviderStatsAction,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { Reducer } from 'redux';\nimport {\n  BALANCER,\n  BalancerAction,\n  IBalancerNetworkSwitchSucceeded,\n} from '../balancerConfig/types';\nimport {\n  IProviderCallSucceeded,\n  IProviderCallTimeout,\n  PROVIDER_CALL,\n  ProviderCallAction,\n} from '../providerCalls/types';\nimport {\n  IWorkerKilled,\n  IWorkerProcessing,\n  IWorkerSpawned,\n  WORKER,\n  WorkerAction,\n} from '../workers/types';\nimport { IWorkerState } from './types';\n\ntype WReducer = Reducer<IWorkerState>;\nconst INITIAL_STATE: IWorkerState = {};\n\nconst handleNetworkSwitch: WReducer = (\n  _: IWorkerState,\n  { payload }: IBalancerNetworkSwitchSucceeded,\n) => {\n  // validation\n  for (const [workerId, worker] of Object.entries(payload.workers)) {\n    if (!worker.task) {\n      throw Error(`Worker ${workerId} has no saga task assigned`);\n    }\n    if (worker.currentPayload) {\n      throw Error(`Worker ${workerId} should not have an existing payload`);\n    }\n  }\n\n  return payload.workers;\n};\n\nconst handleWorkerKilled: WReducer = (\n  state: IWorkerState,\n  { payload }: IWorkerKilled,\n) => {\n  if (!state[payload.workerId]) {\n    throw Error(`Worker ${payload.workerId} does not exist`);\n  }\n\n  const stateCopy = { ...state };\n  Reflect.deleteProperty(stateCopy, payload.workerId);\n  return stateCopy;\n};\n\nconst handleWorkerProcessing: WReducer = (\n  state: IWorkerState,\n  { payload: { currentPayload, workerId } }: IWorkerProcessing,\n) => {\n  if (!state[workerId]) {\n    throw Error(`Worker ${workerId} does not exist`);\n  }\n\n  if (state[workerId].currentPayload) {\n    throw Error(`Worker ${workerId} is already processing a payload`);\n  }\n\n  return {\n    ...state,\n    [workerId]: { ...state[workerId], currentPayload },\n  };\n};\n\nconst handleWorkerSpawned: WReducer = (\n  state: IWorkerState,\n  { payload }: IWorkerSpawned,\n) => {\n  if (state[payload.workerId]) {\n    throw Error(`Worker ${payload.workerId} already exists`);\n  }\n\n  return {\n    ...state,\n    [payload.workerId]: {\n      assignedProvider: payload.providerId,\n      task: payload.task,\n      currentPayload: null,\n    },\n  };\n};\n\nconst handleProviderAdded: WReducer = (\n  state,\n  { payload }: IProviderStatsAdded,\n) => {\n  const stateCopy = { ...state };\n  for (const [workerId, worker] of Object.entries(payload.workers)) {\n    if (stateCopy[workerId]) {\n      throw Error(`Worker ${workerId} already exists`);\n    }\n\n    stateCopy[workerId] = {\n      assignedProvider: worker.assignedProvider,\n      task: worker.task,\n      currentPayload: null,\n    };\n  }\n  return stateCopy;\n};\n\nconst handleProviderCallSucceeded: WReducer = (\n  state: IWorkerState,\n  { payload }: IProviderCallSucceeded,\n) => {\n  const { providerCall: { callId } } = payload;\n  const worker = Object.entries(state).find(\n    ([_, { currentPayload }]) =>\n      !!(currentPayload && currentPayload.callId === callId),\n  );\n\n  if (!worker) {\n    throw Error(`Worker not found for a successful request`);\n  }\n\n  const [workerId, workerInst] = worker;\n\n  return { ...state, [workerId]: { ...workerInst, currentPayload: null } };\n};\n\nconst handleProviderCallTimeout: WReducer = (\n  state: IWorkerState,\n  { payload }: IProviderCallTimeout,\n) => {\n  const { providerCall } = payload;\n  const worker = Object.entries(state).find(\n    ([_, { currentPayload }]) =>\n      !!(currentPayload && currentPayload.callId === providerCall.callId),\n  );\n\n  if (!worker) {\n    throw Error(`Worker not found for a timed out request`);\n  }\n\n  const [workerId, workerInst] = worker;\n\n  return { ...state, [workerId]: { ...workerInst, currentPayload: null } };\n};\n\nexport const workerReducer: WReducer = (\n  state: IWorkerState = INITIAL_STATE,\n  action:\n    | WorkerAction\n    | ProviderCallAction\n    | BalancerAction\n    | ProviderStatsAction,\n): IWorkerState => {\n  switch (action.type) {\n    case WORKER.SPAWNED:\n      return handleWorkerSpawned(state, action);\n    case WORKER.PROCESSING:\n      return handleWorkerProcessing(state, action);\n    case WORKER.KILLED:\n      return handleWorkerKilled(state, action);\n\n    case BALANCER.NETWORK_SWITCH_SUCCEEDED:\n      return handleNetworkSwitch(state, action);\n\n    case PROVIDER_CALL.SUCCEEDED:\n      return handleProviderCallSucceeded(state, action);\n    case PROVIDER_CALL.TIMEOUT:\n      return handleProviderCallTimeout(state, action);\n\n    case PROVIDER_STATS.ADDED:\n      return handleProviderAdded(state, action);\n    default:\n      return state;\n  }\n};\n","import { IProviderCallFlushed } from '@src/ducks/providerBalancer/providerCalls';\nimport {\n  IWorkerProcessing,\n  WORKER,\n  WorkerAction,\n} from '@src/ducks/providerBalancer/workers';\nimport {\n  IProviderCallFailed,\n  IProviderCallRequested,\n  IProviderCallSucceeded,\n  PROVIDER_CALL,\n  ProviderCallAction,\n  ProviderCallsState,\n} from './types';\n\nconst handleProviderCallSucceeded = (\n  state: ProviderCallsState,\n  { payload }: IProviderCallSucceeded,\n): ProviderCallsState => {\n  const call = state[payload.providerCall.callId];\n  if (!call || !call.pending) {\n    throw Error(`Pending provider call not found ${call ? call.callId : ''}`);\n  }\n\n  return {\n    ...state,\n    [payload.providerCall.callId]: {\n      ...payload.providerCall,\n      result: payload.result,\n      error: null,\n      pending: false,\n    },\n  };\n};\n\nconst handleProviderCallFailed = (\n  state: ProviderCallsState,\n  { payload }: IProviderCallFailed,\n): ProviderCallsState => {\n  const call = state[payload.providerCall.callId];\n  if (!call || !call.pending) {\n    throw Error('Pending provider call not found');\n  }\n\n  return {\n    ...state,\n    [payload.providerCall.callId]: {\n      error: payload.error,\n      ...payload.providerCall,\n      result: null,\n      pending: false,\n    },\n  };\n};\n\nconst handleProviderCallFlushed = (\n  state: ProviderCallsState,\n  { payload }: IProviderCallFlushed,\n): ProviderCallsState => {\n  const call = state[payload.providerCall.callId];\n\n  if (!call || !call.pending) {\n    console.error('Pending provider call not found when flushing');\n  }\n\n  return {\n    ...state,\n    [payload.providerCall.callId]: {\n      error: payload.error,\n      ...payload.providerCall,\n      result: null,\n      pending: false,\n    },\n  };\n};\n\nconst handleProviderCallPending = (\n  state: ProviderCallsState,\n  { payload }: IProviderCallRequested,\n): ProviderCallsState => {\n  const call = state[payload.callId];\n\n  // a duplicate check that makes sure the incoming call is either new or a retry call\n  if (call && call.numOfRetries === payload.numOfRetries) {\n    throw Error('Provider call already exists');\n  }\n  return {\n    ...state,\n    [payload.callId]: { ...payload, error: null, result: null, pending: true },\n  };\n};\n\nconst handleWorkerProcessing = (\n  state: ProviderCallsState,\n  { payload: { currentPayload } }: IWorkerProcessing,\n) => {\n  const prevPayload = state[currentPayload.callId];\n  if (!prevPayload || !prevPayload.pending) {\n    throw Error('Pending provider call not found');\n  }\n\n  const nextPayload = { ...prevPayload, providerId: currentPayload.providerId };\n\n  return {\n    ...state,\n    [currentPayload.callId]: nextPayload,\n  };\n};\n\nconst INITIAL_STATE: ProviderCallsState = {};\n\nexport const providerCallsReducer = (\n  state: ProviderCallsState = INITIAL_STATE,\n  action: ProviderCallAction | WorkerAction,\n) => {\n  switch (action.type) {\n    case PROVIDER_CALL.REQUESTED:\n      return handleProviderCallPending(state, action);\n    case WORKER.PROCESSING:\n      return handleWorkerProcessing(state, action);\n    case PROVIDER_CALL.SUCCEEDED:\n      return handleProviderCallSucceeded(state, action);\n    case PROVIDER_CALL.FAILED:\n      return handleProviderCallFailed(state, action);\n    case PROVIDER_CALL.FLUSHED:\n      return handleProviderCallFlushed(state, action);\n    default:\n      return state;\n  }\n};\n","export enum SUBSCRIBE {\n  ACTION = 'SUBSCRIBE_TO_ACTION',\n}\n\nexport interface ISubscribe {\n  type: SUBSCRIBE.ACTION;\n  payload: {\n    trigger: any;\n    callback(resultingAction: any): void;\n  };\n}\n\nexport type SubscribeAction = ISubscribe;\n","import { ISubscribe, SUBSCRIBE } from './types';\n\nexport function subscribeToAction(payload: ISubscribe['payload']): ISubscribe {\n  return { type: SUBSCRIBE.ACTION, payload };\n}\n","import {\n  BALANCER,\n  IBalancerManualFailed,\n  IBalancerManualSucceeded,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { PROVIDER_CALL } from '@src/ducks/providerBalancer/providerCalls';\nimport { subscribeToAction } from '@src/ducks/subscribe';\nimport { AllActions } from '@src/ducks/types';\nimport { Reject, Resolve, RootState } from '@src/types';\nimport { Dispatch } from 'redux';\n\nexport const triggerOnMatchingCallId = (\n  callId: number,\n  includeTimeouts: boolean,\n) => (action: AllActions) => {\n  // check if the action is a provider failed or succeeded call\n  if (\n    action.type === PROVIDER_CALL.SUCCEEDED ||\n    action.type === PROVIDER_CALL.FAILED ||\n    action.type === PROVIDER_CALL.FLUSHED ||\n    (includeTimeouts && action.type === PROVIDER_CALL.TIMEOUT)\n  ) {\n    // make sure its the same call\n    return action.payload.providerCall.callId === callId;\n  }\n};\n\nexport function waitForNetworkSwitch(\n  dispatch: Dispatch<RootState>,\n  id: number,\n) {\n  return new Promise(res =>\n    dispatch(\n      subscribeToAction({\n        trigger: (action: AllActions) => {\n          if (action.type === BALANCER.NETWORK_SWITCH_SUCCEEDED) {\n            return action.meta.id === id;\n          }\n          return false;\n        },\n        callback: res,\n      }),\n    ),\n  );\n}\n\nexport function waitForManualMode(\n  dispatch: Dispatch<RootState>,\n): Promise<string> {\n  function triggerOnSuccessOrFail(action: AllActions) {\n    return (\n      action.type === BALANCER.MANUAL_SUCCEEDED ||\n      action.type === BALANCER.MANUAL_FAILED\n    );\n  }\n\n  const returnSuccessOrFail = (resolve: Resolve, reject: Reject) => (\n    action: IBalancerManualFailed | IBalancerManualSucceeded,\n  ) =>\n    action.type === BALANCER.MANUAL_SUCCEEDED\n      ? resolve(action.payload.providerId)\n      : reject(Error(action.payload.error));\n\n  return new Promise((resolve, reject) =>\n    dispatch(\n      subscribeToAction({\n        trigger: triggerOnSuccessOrFail,\n        callback: returnSuccessOrFail(resolve, reject),\n      }),\n    ),\n  );\n}\n","import { AllProviderMethods, DeepPartial } from '@src/types';\n\nexport enum PROVIDER_CONFIG {\n  ADD = 'PROVIDER_CONFIG_ADD',\n  CHANGE = 'PROVIDER_CONFIG_CHANGE',\n  REMOVE = 'PROVIDER_CONFIG_REMOVE',\n}\n\nexport interface IProviderConfig {\n  /**\n   * @description The maximum number of concurrent calls to make to the provider instance using this config.\n   * This number determines how many workers to spawn to process incoming rpc requests\n   */\n  concurrency: number;\n  /**\n   * @description The threshold of failed calls before deeming a provider to be offline\n   * (which means it will no longer have rpc calls routed to it), which will then be polled until it responds.\n   * If it responds, it will be changed to an online state and continue to have applicable calls as outlined in supportedMethods routed to it\n   */\n  requestFailureThreshold: number;\n  /**\n   * @description How long to wait on an rpc call (also applies to the initial ping to determine if a provider is online) before determining that it has timed out\n   */\n  timeoutThresholdMs: number;\n  /**\n   * @description All supported rpc methods by this provider config,\n   * disable a method for a config by setting it to false, this will\n   * prevent any rpc calls set to false to be routed to the provider instance using this config\n   */\n  supportedMethods: { [rpcMethod in AllProviderMethods]: boolean };\n  /**\n   * @description The associated network name of this provider config to be used by the balancer when switching networks\n   */\n  network: string;\n}\n\nexport interface IProviderConfigState {\n  [key: string]: IProviderConfig;\n}\n\nexport interface IAddProviderConfig {\n  type: PROVIDER_CONFIG.ADD;\n  payload: { id: string; config: IProviderConfig };\n}\n\nexport interface IChangeProviderConfig {\n  type: PROVIDER_CONFIG.CHANGE;\n  payload: { id: string; config: DeepPartial<IProviderConfig> };\n}\n\nexport interface IRemoveProviderConfig {\n  type: PROVIDER_CONFIG.REMOVE;\n  payload: { id: string };\n}\n\nexport type ProviderConfigAction =\n  | IAddProviderConfig\n  | IChangeProviderConfig\n  | IRemoveProviderConfig;\n","import { Reducer } from 'redux';\nimport {\n  IAddProviderConfig,\n  IChangeProviderConfig,\n  IProviderConfigState,\n  IRemoveProviderConfig,\n  PROVIDER_CONFIG,\n  ProviderConfigAction,\n} from './types';\n\nexport const INITIAL_STATE: IProviderConfigState = {};\n\ntype PCReducer = Reducer<IProviderConfigState>;\n\nconst handleProviderConfigAdd: PCReducer = (\n  state,\n  { payload }: IAddProviderConfig,\n) => {\n  if (state[payload.id]) {\n    throw Error(`Provider config ${payload.id} already exists`);\n  }\n  return { ...state, [payload.id]: payload.config };\n};\n\nconst handleProviderConfigChange: PCReducer = (\n  state,\n  { payload }: IChangeProviderConfig,\n) => {\n  const { config, id } = payload;\n  if (!state[id]) {\n    throw Error(`Provider config ${id} does not exist`);\n  }\n\n  return {\n    ...state,\n    [id]: {\n      ...state[id],\n      ...config,\n      supportedMethods: {\n        ...state[id].supportedMethods,\n        ...config.supportedMethods,\n      },\n    },\n  };\n};\n\nconst handleProviderConfigRemove: PCReducer = (\n  state,\n  { payload }: IRemoveProviderConfig,\n) => {\n  if (!state[payload.id]) {\n    throw Error(`Provider config ${payload.id} does not exist`);\n  }\n\n  const stateCopy = { ...state };\n  Reflect.deleteProperty(stateCopy, payload.id);\n  return stateCopy;\n};\n\nexport const providerConfigs = (\n  state: IProviderConfigState = INITIAL_STATE,\n  action: ProviderConfigAction,\n): IProviderConfigState => {\n  switch (action.type) {\n    case PROVIDER_CONFIG.ADD:\n      return handleProviderConfigAdd(state, action);\n    case PROVIDER_CONFIG.CHANGE:\n      return handleProviderConfigChange(state, action);\n    case PROVIDER_CONFIG.REMOVE:\n      return handleProviderConfigRemove(state, action);\n\n    default:\n      return state;\n  }\n};\n","import { IChangeProviderConfig } from '@src/ducks/providerConfigs';\nimport {\n  IAddProviderConfig,\n  IRemoveProviderConfig,\n  PROVIDER_CONFIG,\n} from './types';\n\nexport const addProviderConfig = (\n  payload: IAddProviderConfig['payload'],\n): IAddProviderConfig => ({\n  type: PROVIDER_CONFIG.ADD,\n  payload,\n});\n\nexport const removeProviderConfig = (\n  payload: IRemoveProviderConfig['payload'],\n): IRemoveProviderConfig => ({ type: PROVIDER_CONFIG.REMOVE, payload });\n\nexport const changeProviderConfig = (\n  payload: IChangeProviderConfig['payload'],\n): IChangeProviderConfig => ({ type: PROVIDER_CONFIG.CHANGE, payload });\n","import BN from 'bn.js';\n\nexport function stripHexPrefix(value: string) {\n  return value.replace('0x', '');\n}\n\ntype Wei = BN;\n\nconst handleValues = (input: string | BN | number) => {\n  if (typeof input === 'string') {\n    return input.startsWith('0x')\n      ? new BN(stripHexPrefix(input), 16)\n      : new BN(input);\n  }\n  if (typeof input === 'number') {\n    return new BN(input);\n  }\n  if (BN.isBN(input)) {\n    return input;\n  } else {\n    throw Error('unsupported value conversion');\n  }\n};\n\nconst hexToNumber = (hex: string): number => handleValues(hex).toNumber();\nconst makeBN = handleValues;\nconst Wei = handleValues;\n\nexport { Wei, handleValues, makeBN, hexToNumber };\n","import { IJsonRpcResponse } from '@src/providers/rpc/types';\nimport { Schema, Validator } from 'jsonschema';\n\n// JSONSchema Validations for Rpc responses\nconst v = new Validator();\n\nexport const schema: { [key: string]: Schema } = {\n  RpcProvider: {\n    type: 'object',\n    additionalProperties: true,\n\n    properties: {\n      jsonrpc: { type: 'string' },\n      id: { oneOf: [{ type: 'string' }, { type: 'integer' }] },\n      result: {\n        oneOf: [{ type: 'string' }, { type: 'array' }, { type: 'object' }],\n      },\n\n      status: { type: 'string', pattern: '1' }, // 1 means pass from etherscan\n      message: { type: 'string', pattern: '^OK' },\n    },\n    oneOf: [\n      {\n        additionalProperties: true,\n        type: 'object',\n        required: ['jsonrpc'],\n        properties: { jsonrpc: { type: 'string' } },\n      },\n      {\n        additionalProperties: true,\n\n        type: 'object',\n        required: ['status'],\n        properties: { status: { type: 'string' } },\n      },\n    ],\n\n    dependencies: {\n      jsonrpc: ['id', 'result'],\n      status: ['message', 'result'],\n    },\n    not: {\n      anyOf: [\n        {\n          additionalProperties: true,\n          properties: {\n            error: {\n              anyOf: [\n                { type: 'string', minLength: 1 },\n                { type: ['array', 'object', 'number', 'boolean'] },\n              ],\n            },\n          },\n          required: ['error'],\n        },\n      ],\n    },\n  },\n};\n\nfunction isValidResult(\n  response: IJsonRpcResponse,\n  schemaFormat: typeof schema.RpcProvider,\n): boolean {\n  return v.validate(response, schemaFormat).valid;\n}\n\nfunction formatErrors(response: IJsonRpcResponse, apiType: string) {\n  if (response) {\n    if (response.error && response.error.message) {\n      // Metamask errors are sometimes full-blown stacktraces, no bueno. Instead,\n      // We'll just take the first line of it, and the last thing after all of\n      // the colons. An example error message would be:\n      // \"Error: Metamask Sign Tx Error: User rejected the signature.\"\n      const lines = response.error.message.split('\\n');\n      if (lines.length > 2) {\n        return lines[0].split(':').pop();\n      } else {\n        return `${response.error.message} ${response.error.data || ''}`;\n      }\n    } else if (response.result && (response as any).status) {\n      return response.result;\n    }\n  }\n  return `Invalid ${apiType} Error`;\n}\n\nenum API_NAME {\n  Get_Balance = 'Get Balance',\n  Estimate_Gas = 'Estimate Gas',\n  Call_Request = 'Call Request',\n  Token_Balance = 'Token Balance',\n  Transaction_Count = 'Transaction Count',\n  Current_Block = 'Current Block',\n  Raw_Tx = 'Raw Tx',\n  Send_Transaction = 'Send Transaction',\n  Sign_Message = 'Sign Message',\n  Get_Accounts = 'Get Accounts',\n  Net_Version = 'Net Version',\n  Transaction_By_Hash = 'Transaction By Hash',\n  Transaction_Receipt = 'Transaction Receipt',\n}\n\nconst isValidEthCall = (\n  response: IJsonRpcResponse,\n  schemaType: typeof schema.RpcProvider,\n) => (apiName: API_NAME, cb?: (res: IJsonRpcResponse) => any) => {\n  if (!isValidResult(response, schemaType)) {\n    if (cb) {\n      return cb(response);\n    }\n    throw new Error(formatErrors(response, apiName));\n  }\n  return response;\n};\n\nexport const isValidGetBalance = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Get_Balance);\n\nexport const isValidEstimateGas = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Estimate_Gas);\n\nexport const isValidCallRequest = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Call_Request);\n\nexport const isValidTransactionCount = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Transaction_Count);\n\nexport const isValidTransactionByHash = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Transaction_By_Hash);\n\nexport const isValidTransactionReceipt = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Transaction_Receipt);\n\nexport const isValidCurrentBlock = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Current_Block);\n\nexport const isValidRawTxApi = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Raw_Tx);\n\nexport const isValidSendTransaction = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Send_Transaction);\n\nexport const isValidSignMessage = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Sign_Message);\n\nexport const isValidGetAccounts = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Get_Accounts);\n\nexport const isValidGetNetVersion = (response: IJsonRpcResponse) =>\n  isValidEthCall(response, schema.RpcProvider)(API_NAME.Net_Version);\n","import { StrIdx } from '@src/types';\nimport { randomBytes } from 'crypto';\nimport { IJsonRpcResponse, RPCRequest } from './types';\n\nexport class RPCClient {\n  public endpoint: string;\n  public headers: StrIdx<string>;\n  constructor(endpoint: string, headers: StrIdx<string> = {}) {\n    this.endpoint = endpoint;\n    this.headers = headers;\n  }\n\n  public id(): string | number {\n    return randomBytes(16).toString('hex');\n  }\n\n  public decorateRequest = (req: RPCRequest) => ({\n    ...req,\n    id: this.id(),\n    jsonrpc: '2.0',\n  });\n\n  public call = (request: RPCRequest | any): Promise<IJsonRpcResponse> => {\n    return fetch(this.endpoint, {\n      method: 'POST',\n      headers: this.createHeaders({\n        'Content-Type': 'application/json',\n        ...this.headers,\n      }),\n      body: JSON.stringify(this.decorateRequest(request)),\n    }).then(r => r.json());\n  };\n\n  public batch = (\n    requests: RPCRequest[] | any,\n  ): Promise<IJsonRpcResponse[]> => {\n    return fetch(this.endpoint, {\n      method: 'POST',\n      headers: this.createHeaders({\n        'Content-Type': 'application/json',\n        ...this.headers,\n      }),\n      body: JSON.stringify(requests.map(this.decorateRequest)),\n    }).then(r => r.json());\n  };\n\n  private readonly createHeaders = (headerObject: StrIdx<string>) => {\n    const headers = new Headers();\n    Object.keys(headerObject).forEach(name => {\n      headers.append(name, headerObject[name]);\n    });\n    return headers;\n  };\n}\n","import { IHexStrTransaction, TxObj } from '@src/types';\nimport { stripHexPrefix } from '@src/utils';\nimport {\n  ICallRequest,\n  IEstimateGasRequest,\n  IGetBalanceRequest,\n  IGetCurrentBlockRequest,\n  IGetNetVersionRequest,\n  IGetTransactionByHashRequest,\n  IGetTransactionCountRequest,\n  IGetTransactionReceiptRequest,\n  ISendRawTxRequest,\n} from './types';\n\nexport class RPCRequests {\n  public getNetVersion(): IGetNetVersionRequest | any {\n    return { method: 'net_version' };\n  }\n\n  public sendRawTx(signedTx: string): ISendRawTxRequest | any {\n    return {\n      method: 'eth_sendRawTransaction',\n      params: [signedTx],\n    };\n  }\n\n  public estimateGas(\n    transaction: Partial<IHexStrTransaction>,\n  ): IEstimateGasRequest | any {\n    return {\n      method: 'eth_estimateGas',\n      params: [transaction],\n    };\n  }\n\n  public getBalance(address: string): IGetBalanceRequest | any {\n    return {\n      method: 'eth_getBalance',\n      params: [`0x${stripHexPrefix(address)}`, 'pending'],\n    };\n  }\n\n  public ethCall(txObj: TxObj): ICallRequest | any {\n    return {\n      method: 'eth_call',\n      params: [txObj, 'pending'],\n    };\n  }\n\n  public getTransactionCount(\n    address: string,\n  ): IGetTransactionCountRequest | any {\n    return {\n      method: 'eth_getTransactionCount',\n      params: [address, 'pending'],\n    };\n  }\n\n  public getTransactionByHash(\n    txhash: string,\n  ): IGetTransactionByHashRequest | any {\n    return {\n      method: 'eth_getTransactionByHash',\n      params: [txhash],\n    };\n  }\n\n  public getTransactionReceipt(\n    txhash: string,\n  ): IGetTransactionReceiptRequest | any {\n    return {\n      method: 'eth_getTransactionReceipt',\n      params: [txhash],\n    };\n  }\n\n  public getCurrentBlock(): IGetCurrentBlockRequest | any {\n    return {\n      method: 'eth_blockNumber',\n    };\n  }\n}\n","import {\n  IHexStrTransaction,\n  IRPCProvider,\n  TransactionData,\n  TransactionReceipt,\n  TxObj,\n} from '@src/types';\nimport { hexToNumber, makeBN, Wei } from '@src/utils';\nimport {\n  isValidCallRequest,\n  isValidCurrentBlock,\n  isValidEstimateGas,\n  isValidGetBalance,\n  isValidRawTxApi,\n  isValidTransactionByHash,\n  isValidTransactionCount,\n  isValidTransactionReceipt,\n} from '@src/validators';\nimport { RPCClient } from './client';\nimport { RPCRequests } from './requests';\n\nexport class RPCProvider implements IRPCProvider {\n  protected client: RPCClient;\n  protected requests: RPCRequests;\n\n  constructor(endpoint: string) {\n    this.client = new RPCClient(endpoint);\n    this.requests = new RPCRequests();\n  }\n\n  public getNetVersion(): Promise<string> {\n    return this.client\n      .call(this.requests.getNetVersion())\n      .then(({ result }) => result);\n  }\n\n  public ping(): Promise<boolean> {\n    return this.client\n      .call(this.requests.getNetVersion())\n      .then(() => true)\n      .catch(() => false);\n  }\n\n  public sendCallRequest(txObj: TxObj): Promise<string> {\n    return this.client\n      .call(this.requests.ethCall(txObj))\n      .then(isValidCallRequest)\n      .then(response => response.result);\n  }\n\n  public sendCallRequests(txObjs: TxObj[]): Promise<string[]> {\n    return this.client\n      .batch(txObjs.map(this.requests.ethCall))\n      .then(r => r.map(isValidCallRequest))\n      .then(r => r.map(({ result }) => result));\n  }\n\n  public getBalance(address: string): Promise<Wei> {\n    return this.client\n      .call(this.requests.getBalance(address))\n      .then(isValidGetBalance)\n      .then(({ result }) => Wei(result));\n  }\n\n  public estimateGas(transaction: Partial<IHexStrTransaction>): Promise<Wei> {\n    return this.client\n      .call(this.requests.estimateGas(transaction))\n      .then(isValidEstimateGas)\n      .then(({ result }) => Wei(result))\n      .catch(error => {\n        throw new Error(error.message);\n      });\n  }\n\n  public getTransactionCount(address: string): Promise<string> {\n    return this.client\n      .call(this.requests.getTransactionCount(address))\n      .then(isValidTransactionCount)\n      .then(({ result }) => result);\n  }\n\n  public getCurrentBlock(): Promise<string> {\n    return this.client\n      .call(this.requests.getCurrentBlock())\n      .then(isValidCurrentBlock)\n      .then(({ result }) => makeBN(result).toString());\n  }\n\n  public sendRawTx(signedTx: string): Promise<string> {\n    return this.client\n      .call(this.requests.sendRawTx(signedTx))\n      .then(isValidRawTxApi)\n      .then(({ result }) => {\n        return result;\n      });\n  }\n\n  public getTransactionByHash(txhash: string): Promise<TransactionData> {\n    return this.client\n      .call(this.requests.getTransactionByHash(txhash))\n      .then(isValidTransactionByHash)\n      .then(({ result }) => ({\n        ...result,\n        to: result.to || '0x0',\n        value: Wei(result.value),\n        gasPrice: Wei(result.gasPrice),\n        gas: Wei(result.gas),\n        nonce: hexToNumber(result.nonce),\n        blockNumber: result.blockNumber\n          ? hexToNumber(result.blockNumber)\n          : null,\n        transactionIndex: result.transactionIndex\n          ? hexToNumber(result.transactionIndex)\n          : null,\n      }));\n  }\n\n  public getTransactionReceipt(txhash: string): Promise<TransactionReceipt> {\n    return this.client\n      .call(this.requests.getTransactionReceipt(txhash))\n      .then(isValidTransactionReceipt)\n      .then(({ result }) => ({\n        ...result,\n        transactionIndex: hexToNumber(result.transactionIndex),\n        blockNumber: hexToNumber(result.blockNumber),\n        cumulativeGasUsed: Wei(result.cumulativeGasUsed),\n        gasUsed: Wei(result.gasUsed),\n        status: result.status ? hexToNumber(result.status) : null,\n        root: result.root || null,\n      }));\n  }\n}\n","import { StrIdx } from '@src/types';\nimport btoa from 'btoa';\nimport { RPCProvider } from '../rpc';\nimport { RPCClient } from '../rpc/client';\n\ninterface IMyCryptoCustomProviderConfig {\n  url: string;\n  auth?: {\n    username: string;\n    password: string;\n  };\n}\n\nexport class MyCryptoCustomProvider extends RPCProvider {\n  constructor(config: IMyCryptoCustomProviderConfig) {\n    super(config.url);\n\n    const headers: StrIdx<string> = {};\n    if (config.auth) {\n      const { username, password } = config.auth;\n      headers.Authorization = `Basic ${btoa(`${username}:${password}`)}`;\n    }\n\n    this.client = new RPCClient(config.url, headers);\n  }\n}\n","import URLSearchParams from 'url-search-params';\nimport { RPCClient } from '../rpc/client';\nimport { IJsonRpcResponse } from '../rpc/types';\nimport { EtherscanRequest } from './types';\n\nexport class EtherscanClient extends RPCClient {\n  public encodeRequest(request: EtherscanRequest): string {\n    const encoded = new URLSearchParams();\n    Object.keys(request).forEach((key: keyof EtherscanRequest) => {\n      if (request[key]) {\n        encoded.set(key, request[key]);\n      }\n    });\n    return encoded.toString();\n  }\n\n  public call = (request: EtherscanRequest): Promise<IJsonRpcResponse> =>\n    fetch(this.endpoint, {\n      method: 'POST',\n      headers: new Headers({\n        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n      }),\n      body: this.encodeRequest(request),\n    }).then(r => r.json());\n\n  public batch = (\n    requests: EtherscanRequest[],\n  ): Promise<IJsonRpcResponse[]> => {\n    const promises = requests.map(req => this.call(req));\n    return Promise.all(promises);\n  };\n}\n","import { IHexStrTransaction } from '@src/types';\nimport { RPCRequests } from '../rpc/requests';\nimport {\n  ICallRequest,\n  IEstimateGasRequest,\n  IGetBalanceRequest,\n  IGetCurrentBlockRequest,\n  IGetTransactionByHashRequest,\n  IGetTransactionCountRequest,\n  IGetTransactionReceiptRequest,\n  ISendRawTxRequest,\n} from './types';\n\nexport class EtherscanRequests extends RPCRequests {\n  public sendRawTx(signedTx: string): ISendRawTxRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_sendRawTransaction',\n      hex: signedTx,\n    };\n  }\n\n  public estimateGas(\n    transaction: Pick<\n      IHexStrTransaction & { from: string },\n      'to' | 'data' | 'from' | 'value'\n    >,\n  ): IEstimateGasRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_estimateGas',\n      to: transaction.to,\n      value: transaction.value,\n      data: transaction.data,\n      from: transaction.from,\n    };\n  }\n\n  public getBalance(address: string): IGetBalanceRequest {\n    return {\n      module: 'account',\n      action: 'balance',\n      tag: 'latest',\n      address,\n    };\n  }\n\n  public ethCall(\n    transaction: Pick<IHexStrTransaction, 'to' | 'data'>,\n  ): ICallRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_call',\n      to: transaction.to,\n      data: transaction.data,\n    };\n  }\n\n  public getTransactionByHash(txhash: string): IGetTransactionByHashRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_getTransactionByHash',\n      txhash,\n    };\n  }\n\n  public getTransactionReceipt(txhash: string): IGetTransactionReceiptRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_getTransactionReceipt',\n      txhash,\n    };\n  }\n\n  public getTransactionCount(address: string): IGetTransactionCountRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_getTransactionCount',\n      tag: 'latest',\n      address,\n    };\n  }\n\n  public getCurrentBlock(): IGetCurrentBlockRequest {\n    return {\n      module: 'proxy',\n      action: 'eth_blockNumber',\n    };\n  }\n}\n","import { RPCProvider } from '../rpc';\nimport { EtherscanClient } from './client';\nimport { EtherscanRequests } from './requests';\n\nexport class EtherscanProvider extends RPCProvider {\n  public client: EtherscanClient;\n  public requests: EtherscanRequests;\n\n  constructor(endpoint: string) {\n    super(endpoint);\n    this.client = new EtherscanClient(endpoint);\n    this.requests = new EtherscanRequests();\n  }\n}\n","import { randomBytes } from 'crypto';\nimport { RPCClient } from '../rpc/client';\n\nexport class InfuraClient extends RPCClient {\n  public id(): number {\n    return parseInt(randomBytes(5).toString('hex'), 16);\n  }\n}\n","import { RPCProvider } from '../rpc';\nimport { InfuraClient } from './client';\n\nexport class InfuraProvider extends RPCProvider {\n  public client: InfuraClient;\n\n  constructor(endpoint: string) {\n    super(endpoint);\n    this.client = new InfuraClient(endpoint);\n  }\n}\n","import { RPCClient } from '../rpc/client';\nimport { IJsonRpcResponse, RPCRequest } from '../rpc/types';\nimport { IWeb3Provider } from './types';\n\nexport class Web3Client extends RPCClient {\n  private readonly provider: IWeb3Provider;\n\n  constructor() {\n    super('web3'); // initialized with fake endpoint\n    this.provider = (window as any).web3.currentProvider;\n  }\n\n  public decorateRequest = (req: RPCRequest) => ({\n    ...req,\n    id: this.id(),\n    jsonrpc: '2.0',\n    params: req.params || [], // default to empty array so MetaMask doesn't error\n  });\n\n  public call = (request: RPCRequest | any): Promise<IJsonRpcResponse> =>\n    this.sendAsync(this.decorateRequest(request)) as Promise<IJsonRpcResponse>;\n\n  public batch = (requests: RPCRequest[] | any): Promise<IJsonRpcResponse[]> =>\n    this.sendAsync(requests.map(this.decorateRequest)) as Promise<\n      IJsonRpcResponse[]\n    >;\n\n  private readonly sendAsync = (\n    request: any,\n  ): Promise<IJsonRpcResponse | IJsonRpcResponse[]> => {\n    return new Promise((resolve, reject) => {\n      this.provider.sendAsync(\n        request,\n        (error, result: IJsonRpcResponse | IJsonRpcResponse[]) => {\n          if (error) {\n            return reject(error);\n          }\n          resolve(result);\n        },\n      );\n    });\n  };\n}\n","import { IHexStrWeb3Transaction } from '@src/types';\nimport { RPCRequests } from '../rpc/requests';\nimport {\n  IGetAccountsRequest,\n  ISendTransactionRequest,\n  ISignMessageRequest,\n} from './types';\n\nexport class Web3Requests extends RPCRequests {\n  public sendTransaction(\n    web3Tx: IHexStrWeb3Transaction,\n  ): ISendTransactionRequest {\n    return {\n      method: 'eth_sendTransaction',\n      params: [web3Tx],\n    };\n  }\n\n  public signMessage(msgHex: string, fromAddr: string): ISignMessageRequest {\n    return {\n      method: 'personal_sign',\n      params: [msgHex, fromAddr],\n    };\n  }\n\n  public getAccounts(): IGetAccountsRequest {\n    return {\n      method: 'eth_accounts',\n    };\n  }\n}\n","import { IHexStrWeb3Transaction, IProvider } from '@src/types';\nimport {\n  isValidGetAccounts,\n  isValidGetNetVersion,\n  isValidSendTransaction,\n  isValidSignMessage,\n} from '@src/validators';\nimport { RPCProvider } from '../rpc';\nimport { Web3Client } from './client';\nimport { Web3Requests } from './requests';\n\nexport class Web3Provider extends RPCProvider {\n  public client: Web3Client;\n  public requests: Web3Requests;\n\n  constructor() {\n    super('web3'); // initialized with fake endpoint\n    this.client = new Web3Client();\n    this.requests = new Web3Requests();\n  }\n\n  public getNetVersion(): Promise<string> {\n    return this.client\n      .call(this.requests.getNetVersion())\n      .then(isValidGetNetVersion)\n      .then(({ result }) => result);\n  }\n\n  public sendTransaction(web3Tx: IHexStrWeb3Transaction): Promise<string> {\n    return this.client\n      .call(this.requests.sendTransaction(web3Tx))\n      .then(isValidSendTransaction)\n      .then(({ result }) => result);\n  }\n\n  public signMessage(msgHex: string, fromAddr: string): Promise<string> {\n    return this.client\n      .call(this.requests.signMessage(msgHex, fromAddr))\n      .then(isValidSignMessage)\n      .then(({ result }) => result);\n  }\n\n  public getAccounts(): Promise<string> {\n    return this.client\n      .call(this.requests.getAccounts())\n      .then(isValidGetAccounts)\n      .then(({ result }) => result);\n  }\n}\n\nexport function isWeb3Provider(\n  provider: IProvider | Web3Provider,\n): provider is Web3Provider {\n  return provider instanceof Web3Provider;\n}\n\nexport const Web3Service = 'MetaMask / Mist';\n\nexport async function setupWeb3Provider() {\n  const { web3 } = window as any;\n\n  if (!web3 || !web3.currentProvider || !web3.currentProvider.sendAsync) {\n    throw new Error(\n      'Web3 not found. Please check that MetaMask is installed, or that MyEtherWallet is open in Mist.',\n    );\n  }\n\n  const provider = new Web3Provider();\n  const networkId = await provider.getNetVersion();\n  const accounts = await provider.getAccounts();\n\n  if (!accounts.length) {\n    throw new Error('No accounts found in MetaMask / Mist.');\n  }\n\n  if (networkId === 'loading') {\n    throw new Error(\n      'MetaMask / Mist is still loading. Please refresh the page and try again.',\n    );\n  }\n\n  return { networkId, provider };\n}\n\nexport async function isWeb3ProviderAvailable(): Promise<boolean> {\n  try {\n    await setupWeb3Provider();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n","import { MyCryptoCustomProvider } from '@src/providers/custom';\nimport { EtherscanProvider } from '@src/providers/etherscan';\nimport { InfuraProvider } from '@src/providers/infura';\nimport { RPCProvider } from '@src/providers/rpc';\nimport { Web3Provider } from '@src/providers/web3';\nimport {\n  IProvider,\n  IProviderContructor,\n  IRPCProvider,\n  IRPCProviderContructor,\n  StrIdx,\n} from '@src/types';\n\ninterface IProviderStorage {\n  setClass(\n    providerName: string,\n    Provider: IProviderContructor | IRPCProviderContructor,\n  ): void;\n  getClass(providerName: string): IProviderContructor | IRPCProviderContructor;\n  setInstance(providerName: string, provider: IProvider | IRPCProvider): void;\n  getInstance(providerName: string): IProvider | IRPCProvider;\n}\n\nclass ProviderStorage implements IProviderStorage {\n  private readonly instances: Partial<StrIdx<IProvider | IRPCProvider>>;\n  private readonly classes: Partial<\n    StrIdx<IProviderContructor | IRPCProviderContructor>\n  >;\n\n  constructor(\n    providers: StrIdx<IProviderContructor | IRPCProviderContructor> = {},\n  ) {\n    this.classes = providers;\n    this.instances = {};\n  }\n\n  /**\n   * Sets the class\n   * @param providerName\n   * @param Provider\n   */\n  public setClass(\n    providerName: string,\n    Provider: IProviderContructor | IRPCProviderContructor,\n  ) {\n    this.classes[providerName] = Provider;\n  }\n\n  public getClass(providerName: string) {\n    const Provider = this.classes[providerName];\n    if (!Provider) {\n      throw Error(`${providerName} implementation does not exist in storage`);\n    }\n    return Provider;\n  }\n\n  public setInstance(providerName: string, provider: IProvider | IRPCProvider) {\n    this.instances[providerName] = provider;\n  }\n\n  public getInstance(providerName: string) {\n    const provider = this.instances[providerName];\n    if (!provider) {\n      throw Error(`${providerName} instance does not exist in storage`);\n    }\n    return provider;\n  }\n}\n\nexport const providerStorage = new ProviderStorage({\n  rpc: RPCProvider,\n  etherscan: EtherscanProvider,\n  infura: InfuraProvider,\n  web3: Web3Provider,\n  myccustom: MyCryptoCustomProvider,\n});\n","import { getRootState } from '@src/ducks/rootState';\nimport { providerStorage } from '@src/providers/providerStorage';\nimport { AllProviderMethods, RootState } from '@src/types';\nimport { IProviderConfigState } from './types';\n\nexport const getProviderConfigs = (state: RootState) =>\n  getRootState(state).providerConfigs;\n\nexport const getProviderConfigById = (\n  state: RootState,\n  id: string,\n): IProviderConfigState[string] | undefined => getProviderConfigs(state)[id];\n\nexport const providerSupportsMethod = (\n  state: RootState,\n  id: string,\n  method: AllProviderMethods,\n): boolean => {\n  const config = getProviderConfigById(state, id);\n  return !!(config && config.supportedMethods[method]);\n};\n\nexport const getProviderTimeoutThreshold = (state: RootState, id: string) => {\n  const config = getProviderConfigById(state, id);\n  if (!config) {\n    throw Error(`Could not find config for provider ${id}`);\n  }\n  return config.timeoutThresholdMs;\n};\n\nexport const getProviderInstAndTimeoutThreshold = (\n  state: RootState,\n  id: string,\n) => {\n  const provider = providerStorage.getInstance(id);\n  const timeoutThreshold = getProviderTimeoutThreshold(state, id);\n  return { provider, timeoutThreshold };\n};\n","import { addProviderConfig, IProviderConfig } from '@src/ducks/providerConfigs';\nimport { storeManager } from '@src/ducks/store';\nimport { IProviderContructor } from '@src/types';\nimport { providerStorage } from './providerStorage';\n\nexport function addProvider(\n  providerName: string,\n  Provider: IProviderContructor,\n) {\n  return providerStorage.setClass(providerName, Provider);\n}\n\nexport function useProvider(\n  providerName: string,\n  instanceName: string,\n  config: IProviderConfig,\n  ...args: any[]\n) {\n  const Provider = providerStorage.getClass(providerName);\n  const provider = new Provider(...args);\n  providerStorage.setInstance(instanceName, provider);\n  const action = addProviderConfig({ config, id: instanceName });\n  storeManager.getStore().dispatch(action);\n  return config;\n}\n","import { AllProviderMethods } from '@src/types';\n\nexport const allRPCMethods: (AllProviderMethods)[] = [\n  'ping',\n  'getNetVersion',\n  'sendCallRequest',\n  'sendCallRequests',\n  'getBalance',\n  'estimateGas',\n  'getTransactionCount',\n  'getTransactionReceipt',\n  'getTransactionByHash',\n  'getCurrentBlock',\n  'sendRawTx',\n\n  /*web3 specific methods */\n  'sendTransaction',\n  'signMessage',\n];\n","import { getManualMode } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  IProviderCall,\n  IProviderCallFailed,\n  IProviderCallFlushed,\n  IProviderCallSucceeded,\n  PROVIDER_CALL,\n  providerCallRequested,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { storeManager } from '@src/ducks/store';\nimport { subscribeToAction } from '@src/ducks/subscribe';\nimport { triggerOnMatchingCallId } from '@src/ducks/subscribe/utils';\nimport { AllProviderMethods, IProvider, Reject, Resolve } from '@src/types';\nimport { idGeneratorFactory } from '@src/utils/idGenerator';\nimport { logger } from '@src/utils/logging';\nimport { allRPCMethods } from './constants';\n\nconst idGenerator = idGeneratorFactory();\n\nconst respondToCallee = (resolve: Resolve, reject: Reject) => (\n  action: IProviderCallFailed | IProviderCallSucceeded | IProviderCallFlushed,\n) => {\n  if (action.type === PROVIDER_CALL.SUCCEEDED) {\n    const { providerCall, result } = action.payload;\n\n    logger.log(`CallId: ${providerCall.callId} Pid: ${providerCall.providerId}\n     ${providerCall.rpcMethod} ${providerCall.rpcArgs}\n     Result: ${result}`);\n\n    resolve(action.payload.result);\n  } else {\n    reject(Error(action.payload.error));\n  }\n};\n\nconst makeProviderCall = (\n  rpcMethod: AllProviderMethods,\n  rpcArgs: string[],\n): IProviderCall => {\n  const isManual = getManualMode(storeManager.getStore().getState());\n\n  const providerCall: IProviderCall = {\n    callId: idGenerator(),\n    numOfRetries: 0,\n    rpcArgs,\n    rpcMethod,\n    minPriorityProviderList: [],\n    ...(isManual ? { providerWhiteList: [isManual] } : {}),\n  };\n\n  return providerCall;\n};\n\nconst dispatchRequest = (providerCall: IProviderCall) => {\n  // make the request to the load balancer\n  const networkReq = providerCallRequested(providerCall);\n  storeManager.getStore().dispatch(networkReq);\n  return networkReq.payload.callId;\n};\n\nconst waitForResponse = (callId: number) =>\n  new Promise((resolve, reject) =>\n    storeManager.getStore().dispatch(\n      subscribeToAction({\n        trigger: triggerOnMatchingCallId(callId, false),\n        callback: respondToCallee(resolve, reject),\n      }),\n    ),\n  );\n\nconst providerCallDispatcher = (rpcMethod: AllProviderMethods) => (\n  ...rpcArgs: string[]\n) => {\n  const providerCall = makeProviderCall(rpcMethod, rpcArgs);\n  const callId = dispatchRequest(providerCall);\n  return waitForResponse(callId);\n};\n\nconst handler: ProxyHandler<IProvider> = {\n  get: (target, methodName: AllProviderMethods) => {\n    if (!allRPCMethods.includes(methodName)) {\n      return target[methodName];\n    }\n    return providerCallDispatcher(methodName);\n  },\n};\n\nexport const createProviderProxy = () => new Proxy({} as IProvider, handler);\n","import {\n  balancerInit,\n  balancerNetworkSwitchRequested,\n  setAuto,\n  setManualRequested,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { getManualMode } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport { IProviderConfig } from '@src/ducks/providerConfigs';\nimport { storeManager } from '@src/ducks/store';\nimport {\n  waitForManualMode,\n  waitForNetworkSwitch,\n} from '@src/ducks/subscribe/utils';\nimport { IProviderContructor } from '@src/types';\nimport { IInitConfig, IShepherd } from '@src/types/api';\nimport { logger } from '@src/utils/logging';\nimport { addProvider, createProviderProxy, useProvider } from './providers';\n\nclass Shepherd implements IShepherd {\n  /**\n   *\n   * @description Initializes the balancer, returning a single instance of a provider to be used across your application\n   * @param {IInitConfig} [{ customProviders, ...config }={}] Initialization configuration parameter, custom providers are\n   * your own supplied implementations that adhere to the {IProvider} interface. The {providerCallRetryThreshold} determines\n   * how many times a provider can fail a call before its determined to be offline. The {network} is what network the balancer\n   * will initialize to, defaulting to 'ETH'. The {storeRoot} is the shepherd rootReducer when using a custom store.\n   * E.g If the top level is { foo, shepherdReducer } then `storeRoot` would be `shepherdReducer`. Note that this setting only supports one level of nesting.\n   * The {store} is the custom store to use if you want to use your own, make sure to supply the setting above too or else it will not work.\n   * {queueTimeout} is the timeout based on when there are pending calls that have not been assigned to a worker. The most common case of this happening\n   * is when the balancer is offline and there's calls to the balancer still happening.\n   * @returns {Promise<IProvider>} A provider instances to be used for making rpc calls\n   * @memberof Shepherd\n   */\n  public async init({\n    customProviders,\n    storeRoot,\n    store,\n    ...config\n  }: IInitConfig = {}) {\n    if (storeRoot) {\n      storeManager.setRoot(storeRoot);\n    }\n\n    if (store) {\n      storeManager.setStore(store);\n    }\n\n    if (customProviders) {\n      for (const [customProviderName, Provider] of Object.entries(\n        customProviders,\n      )) {\n        addProvider(customProviderName, Provider);\n      }\n    }\n\n    if (!config.network) {\n      config.network = 'ETH';\n    }\n\n    if (!config.providerCallRetryThreshold) {\n      config.providerCallRetryThreshold = 3;\n    }\n    const node = createProviderProxy();\n    const initAction = balancerInit(config);\n\n    const promise = waitForNetworkSwitch(\n      storeManager.getStore().dispatch,\n      initAction.meta.id,\n    );\n\n    storeManager.getStore().dispatch(initAction);\n    await promise;\n    return node;\n  }\n\n  /**\n   *\n   * @description Adds a custom Provider implementation to be later used and instantiated by useProvider.\n   * This library comes with default Provider implementations of 'rpc' 'etherscan' 'infura' 'web3' 'myccustom'\n   * already availble for use in useProvider. This method can be used before init\n   * @param {string} providerName\n   * @param {IProviderContructor} Provider The provider implementation to store for later usage\n   * @returns {void}\n   * @memberof Shepherd\n   */\n  public addProvider(providerName: string, Provider: IProviderContructor) {\n    addProvider(providerName, Provider);\n  }\n\n  /**\n   * @description Switches the balancer back to \"auto\" mode. This is the default mode of the balancer.\n   * If the balancer was previously in \"manual\" mode, this will now instead change it back to normal\n   * behaviour, which means balancing between all available providers of the current network\n   * @returns {void}\n   * @memberof Shepherd\n   */\n  public auto() {\n    storeManager.getStore().dispatch(setAuto());\n  }\n\n  /**\n   *\n   * @description Switches the balancer to \"manual\" mode. This will switch the balancer's current network\n   * to the manual providers network if it is different, then route all requests to the provider. This method\n   * can be used before init\n   * @param {string} providerId\n   * @param {boolean} skipOfflineCheck Will not fail and throw an error if the manual provider switched to\n   * is offline\n   * @returns {Promise<string>} Resolves when the manual provider has successfully been switched to,\n   * returns a promise containing the provider ID switched to\n   * @memberof Shepherd\n   */\n  public async manual(providerId: string, skipOfflineCheck: boolean) {\n    const promise = waitForManualMode(storeManager.getStore().dispatch);\n    storeManager\n      .getStore()\n      .dispatch(setManualRequested({ providerId, skipOfflineCheck }));\n    return await promise;\n  }\n\n  /**\n   * @description Add a provider instance to the balancer to be used for incoming rpc calls,\n   * this is distinctly different from addProvider, as addProvider does not add any providers to be\n   * used for incoming calls. All addProvider does is add a custom implementation to the pool of default\n   * implementations that you can specify in this method to be used and have instances created from.\n   * This method can be used before init\n   * @param {string} providerName The name of the Provider implementation to use as previously defined in\n   * either init (as customProviders), or addProvider, or one of the default implementations supplied:\n   * 'rpc' 'etherscan' 'infura' 'web3' 'myccustom'\n   * @param {string} instanceName The unique name of the instance to be used\n   * @param {IProviderConfig} config\n   * @param {...any[]} args The constructor arguments to be supplied to the specifed Provider constructor\n   * @returns {void}\n   * @memberof Shepherd\n   */\n  public useProvider(\n    providerName: string,\n    instanceName: string,\n    config: IProviderConfig,\n    ...args: any[]\n  ) {\n    useProvider(providerName, instanceName, config, ...args);\n  }\n\n  /**\n   * @description Switch the network for the balancer to use, all provider instances added by useProvider\n   * that match the same network to be swiched to will be used. Can not be used when the balancer is in\n   * manual mode, switch to auto mode first.\n   * @param {string} network\n   * @returns {Promise<void>} Resolves when the network is finished being switched to\n   * @memberof Shepherd\n   */\n  public async switchNetworks(network: string) {\n    if (getManualMode(storeManager.getStore().getState())) {\n      throw Error(`Can't switch networks when in manual mode!`);\n    }\n    const action = balancerNetworkSwitchRequested({ network });\n\n    const promise = waitForNetworkSwitch(\n      storeManager.getStore().dispatch,\n      action.meta.id,\n    );\n    storeManager.getStore().dispatch(action);\n    await promise;\n  }\n\n  /**\n   * @description enables logging for the library\n   * @memberof Shepherd\n   */\n  public enableLogging() {\n    logger.enableLogging();\n  }\n}\n\nexport const shepherd = new Shepherd();\n","import { AllActions } from '@src/ducks/types';\nimport { Dispatch, Middleware } from 'redux';\n\nimport { SUBSCRIBE } from '@src/ducks/subscribe';\n// this should be the last middleware, immediately before the store\n// if it's an subscription action then do not dispatch it to the store\nexport const filterMiddlware: Middleware = () => (\n  next: Dispatch<AllActions>,\n) => (action: AllActions): any =>\n  action.type === SUBSCRIBE.ACTION ? undefined : next(action);\n","import { combineReducers } from 'redux';\nimport { balancerConfigReducer } from './balancerConfig';\nimport * as balancerConfigSelectors from './balancerConfig/selectors';\n\nimport { providerCallsReducer } from './providerCalls';\nimport * as providerCallsSelectors from './providerCalls/selectors';\n\nimport { providerStatsReducer } from './providerStats';\nimport * as providerStatsSelectors from './providerStats/selectors';\n\nimport { workerReducer } from './workers';\nimport * as workersSelectors from './workers/selectors';\n\nimport { IProviderBalancerState } from './types';\nexport * from './types';\n\nexport const providerBalancer = combineReducers<IProviderBalancerState>({\n  providerStats: providerStatsReducer,\n  workers: workerReducer,\n  balancerConfig: balancerConfigReducer,\n  providerCalls: providerCallsReducer,\n});\n\nexport const providerBalancerSelectors = {\n  balancerConfigSelectors,\n  providerCallsSelectors,\n  providerStatsSelectors,\n  workersSelectors,\n};\n","import { ISubscribe, SUBSCRIBE } from '@src/ducks/subscribe';\nimport { SagaIterator } from 'redux-saga';\nimport { take, takeEvery } from 'redux-saga/effects';\n\nfunction* handleSubscribeToAction({ payload }: ISubscribe): SagaIterator {\n  const { trigger, callback } = payload;\n  const resultingAction = yield take(trigger);\n  callback(resultingAction);\n}\n\nexport const subscriptionWatcher = [\n  takeEvery(SUBSCRIBE.ACTION, handleSubscribeToAction),\n];\n","import { IBalancerNetworkSwitchSucceeded } from '@src/ducks/providerBalancer/balancerConfig';\nimport {\n  IProviderCall,\n  ProviderCallWithPid,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport {\n  IProviderStats,\n  ProcessedProvider,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { IWorker } from '@src/ducks/providerBalancer/workers';\nimport { Task } from 'redux-saga';\n\nexport const createRetryCall = (\n  currentCall: ProviderCallWithPid,\n): IProviderCall => {\n  const { providerId } = currentCall;\n  const currMinList = currentCall.minPriorityProviderList;\n  const nextMinPriorityList = currMinList.includes(providerId)\n    ? currMinList\n    : [...currMinList, providerId];\n\n  const nextCall = {\n    ...currentCall,\n    minPriorityProviderList: nextMinPriorityList,\n    numOfRetries: ++currentCall.numOfRetries,\n  };\n\n  return nextCall;\n};\n\nexport const addProviderIdToCall = (\n  call: IProviderCall,\n  providerId: string,\n): ProviderCallWithPid => ({\n  ...call,\n  providerId,\n});\n\nexport const trackTime = () => {\n  const startTime = new Date();\n  return {\n    end() {\n      const endTime = new Date();\n      const avgResponseTime = +endTime - +startTime;\n      return avgResponseTime;\n    },\n  };\n};\n\nexport const makeProviderStats = (\n  timer: any,\n  isOffline: boolean,\n): IProviderStats => ({\n  avgResponseTime: timer.end(),\n  isOffline,\n  currWorkersById: [],\n  requestFailures: 0,\n});\n\nexport const makeWorkerId = (providerId: string, workerNumber: number) =>\n  `${providerId}_worker_${workerNumber}`;\n\nexport const makeWorker = (providerId: string, task: Task): IWorker => ({\n  assignedProvider: providerId,\n  currentPayload: null,\n  task,\n});\n\ntype NetworkPayload = IBalancerNetworkSwitchSucceeded['payload'];\n\nexport const reduceProcessedProviders = (\n  processedProviders: ProcessedProvider[],\n  network: string,\n): NetworkPayload => {\n  const initialState: NetworkPayload = {\n    providerStats: {},\n    workers: {},\n    network,\n  };\n\n  return processedProviders.reduce((accu, currProvider) => {\n    const curProviderStats: NetworkPayload['providerStats'] = {\n      [currProvider.providerId]: currProvider.stats,\n    };\n\n    const providerStats: NetworkPayload['providerStats'] = {\n      ...accu.providerStats,\n      ...curProviderStats,\n    };\n\n    const workers: NetworkPayload['workers'] = {\n      ...accu.workers,\n      ...currProvider.workers,\n    };\n\n    return {\n      ...accu,\n      providerStats,\n      workers,\n    };\n  }, initialState);\n};\n\nexport const makeRetVal = (\n  error: Error | null = null,\n  result: string | null = null,\n) => ({ result, error });\n","import {\n  IProviderCallRequested,\n  providerCallFlushed,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { subscribeToAction } from '@src/ducks/subscribe';\nimport { triggerOnMatchingCallId } from '@src/ducks/subscribe/utils';\nimport { Channel, SagaIterator } from 'redux-saga';\nimport { apply, flush, put, take } from 'redux-saga/effects';\n\nexport abstract class BaseChannel {\n  protected chan: Channel<IProviderCallRequested> | undefined;\n  protected name: string | undefined;\n  private currentAction: IProviderCallRequested | null | undefined;\n  private readonly shouldLog = false;\n\n  public get() {\n    if (!this.chan) {\n      throw Error(`Channel not assigned yet`);\n    }\n\n    return this.chan;\n  }\n\n  public abstract init(): void;\n\n  public *take(): SagaIterator {\n    const action: IProviderCallRequested = yield take(this.get());\n    // set the current action, so when we flush all of the actions we dont miss the currently processing one\n    const callid = action.payload.callId;\n    this.currentAction = action;\n    this.log(`took call`, action.payload.callId);\n\n    // set the current action to null when it isnt in a state of \"requested\"\n    yield put(\n      subscribeToAction({\n        trigger: triggerOnMatchingCallId(\n          this.currentAction.payload.callId,\n          true,\n        ),\n        callback: () => {\n          this.log(\n            `call ${this.currentAction &&\n              this.currentAction.payload.callId} is now null `,\n          );\n          this.currentAction = null;\n        },\n      }),\n    );\n    this.log(`Returning ${this.currentAction} ${callid}`);\n    return this.currentAction;\n  }\n\n  public *cancelPendingCalls(): SagaIterator {\n    const pendingCalls: IProviderCallRequested[] = yield apply(\n      this,\n      this.getPendingCalls,\n    );\n    for (const { payload } of pendingCalls) {\n      yield put(\n        providerCallFlushed({\n          error: 'Call Flushed',\n          providerCall: payload,\n        }),\n      );\n    }\n  }\n\n  protected log(...args: any[]) {\n    if (this.shouldLog) {\n      console.log(this.name, ...args);\n    }\n  }\n\n  private *flushChannel(): SagaIterator {\n    const messages = yield flush(this.get());\n    this.log(`flushing`);\n    this.log(messages);\n    return messages;\n  }\n\n  private *getPendingCalls(): SagaIterator {\n    const queuedCalls = yield apply(this, this.flushChannel);\n    const pendingCalls = this.currentAction\n      ? [...queuedCalls, this.currentAction]\n      : queuedCalls;\n\n    this.log(`get pending calls`);\n    this.log(pendingCalls);\n\n    this.currentAction = null;\n    return pendingCalls;\n  }\n}\n","import { PROVIDER_CALL } from '@src/ducks/providerBalancer/providerCalls';\nimport { BaseChannel } from '@src/saga/channels/base';\nimport { buffers, SagaIterator } from 'redux-saga';\nimport { actionChannel } from 'redux-saga/effects';\n\nexport class BalancerChannel extends BaseChannel {\n  public name = 'Balancer Channel';\n\n  public *init(): SagaIterator {\n    this.chan = yield actionChannel(\n      PROVIDER_CALL.REQUESTED,\n      buffers.expanding(50),\n    );\n  }\n}\n","import { BaseChannel } from '@src/saga/channels/base';\nimport { buffers, channel } from 'redux-saga';\nimport { apply, call } from 'redux-saga/effects';\n\nclass ProviderChannel extends BaseChannel {\n  public name = 'Provider Channel';\n  public *init() {\n    this.chan = yield call(channel, buffers.expanding(10));\n  }\n}\n\nexport function* providerChannelFactory() {\n  const chan = new ProviderChannel();\n  yield apply(chan, chan.init);\n  return chan;\n}\n","import {\n  IProviderCall,\n  IProviderCallRequested,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { BaseChannel } from '@src/saga/channels/base';\nimport { providerChannelFactory } from '@src/saga/channels/providerChannel';\nimport { StrIdx } from '@src/types';\nimport { SagaIterator } from 'redux-saga';\nimport { apply, call, put } from 'redux-saga/effects';\n\nexport class ProviderChannels {\n  private readonly providerChannels: StrIdx<BaseChannel>;\n\n  constructor() {\n    this.providerChannels = {};\n  }\n\n  public *put(\n    providerId: string,\n    action: IProviderCallRequested,\n  ): SagaIterator {\n    const chan = this.getChannel(providerId).get();\n    yield put(chan, action);\n  }\n\n  public *createChannel(providerId: string): SagaIterator {\n    if (this.providerChannels[providerId]) {\n      throw Error(`${providerId} already has an existing channel open`);\n    }\n\n    const providerChannel: BaseChannel = yield call(providerChannelFactory);\n    this.providerChannels[providerId] = providerChannel;\n  }\n\n  public *take(providerId: string): SagaIterator {\n    const channel = this.getChannel(providerId);\n    const action: IProviderCall = yield apply(channel, channel.take);\n    return action;\n  }\n\n  public *cancelPendingCalls(): SagaIterator {\n    const chans = Object.values(this.providerChannels);\n    for (const chan of chans) {\n      yield apply(chan, chan.cancelPendingCalls);\n    }\n  }\n\n  public deleteAllChannels() {\n    for (const providerId of Object.keys(this.providerChannels)) {\n      this.deleteChannel(providerId);\n    }\n  }\n\n  private deleteChannel(providerId: string) {\n    //check for existence\n    this.getChannel(providerId);\n    Reflect.deleteProperty(this.providerChannels, providerId);\n  }\n\n  private getChannel(providerId: string) {\n    const channel = this.providerChannels[providerId];\n    if (!channel) {\n      throw Error(`${providerId} does not have an existing channel`);\n    }\n    return channel;\n  }\n}\n","import { BalancerChannel } from './balancerChannel';\nimport { ProviderChannels } from './providerChannels';\nexport const balancerChannel = new BalancerChannel();\nexport const providerChannels = new ProviderChannels();\n","import {\n  IProviderCallRequested,\n  isStaleCall,\n  providerCallFailed,\n  providerCallSucceeded,\n  providerCallTimeout,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { workerProcessing } from '@src/ducks/providerBalancer/workers';\nimport { getProviderInstAndTimeoutThreshold } from '@src/ducks/providerConfigs';\nimport { providerChannels } from '@src/saga/channels';\nimport { addProviderIdToCall, makeRetVal } from '@src/saga/sagaUtils';\nimport { AllProviderMethods } from '@src/types';\nimport { logger } from '@src/utils/logging';\nimport { delay } from 'redux-saga';\nimport { apply, call, cancelled, put, race, select } from 'redux-saga/effects';\n\nconst isWeb3Method = (rpcMethod: AllProviderMethods) =>\n  rpcMethod === 'sendTransaction' || rpcMethod === 'signMessage';\n\nfunction* sendRequestToProvider(\n  providerId: string,\n  rpcMethod: AllProviderMethods,\n  rpcArgs: any,\n) {\n  try {\n    const {\n      provider,\n      timeoutThreshold,\n    }: ReturnType<typeof getProviderInstAndTimeoutThreshold> = yield select(\n      getProviderInstAndTimeoutThreshold,\n      providerId,\n    );\n\n    // make the call in the allotted timeout time\n    const { result } = yield race({\n      result: apply(provider, (provider as any)[rpcMethod], rpcArgs),\n      // HACK: If it's an web3 method, then wait 5 minutes because it can be intercepted (see metamask) and then waits on user confirmation\n      // TODO: refactor this to support web3 providers natively\n      timeout: call(\n        delay,\n        isWeb3Method(rpcMethod) ? 60 * 1000 * 5 : timeoutThreshold,\n      ),\n    });\n\n    if (!result) {\n      const error = Error(`Request timed out for ${providerId}`);\n      return makeRetVal(error);\n    }\n\n    return makeRetVal(null, result);\n  } catch (error) {\n    return makeRetVal(error);\n  }\n}\n\nfunction* processRequest(providerId: string, workerId: string) {\n  // take from the assigned action channel\n  const { payload }: IProviderCallRequested = yield apply(\n    providerChannels,\n    providerChannels.take,\n    [providerId],\n  );\n  const { rpcArgs, rpcMethod } = payload;\n  const callWithPid = addProviderIdToCall(payload, providerId);\n\n  if (yield select(isStaleCall, payload.callId)) {\n    logger.log(`Call ${payload.callId} is stale before processing`);\n    return;\n  }\n  // after taking a request, declare processing state\n  yield put(workerProcessing({ currentPayload: callWithPid, workerId }));\n\n  const { result, error } = yield call(\n    sendRequestToProvider,\n    providerId,\n    rpcMethod,\n    rpcArgs,\n  );\n\n  if (yield select(isStaleCall, payload.callId)) {\n    logger.log(`Call ${payload.callId} is stale after processing`);\n    return;\n  }\n\n  if (result) {\n    const action = providerCallSucceeded({\n      result,\n      providerCall: callWithPid,\n    });\n    return yield put(action);\n  } else {\n    const actionParams = {\n      providerCall: callWithPid,\n      error,\n    };\n    const action = isWeb3Method(rpcMethod)\n      ? providerCallFailed(actionParams)\n      : providerCallTimeout(actionParams);\n\n    return yield put(action);\n  }\n}\n\nfunction* processIncomingRequests(thisId: string, providerId: string) {\n  while (true) {\n    yield call(processRequest, providerId, thisId);\n  }\n}\n\nexport function* createWorker(thisId: string, providerId: string) {\n  try {\n    yield call(processIncomingRequests, thisId, providerId);\n  } catch (e) {\n    console.error(`${thisId} as errored with ${e.message}`);\n  } finally {\n    if (yield cancelled()) {\n      logger.log(`${thisId} has been cancelled`);\n    }\n  }\n}\n","import { IWorker } from '@src/ducks/providerBalancer/workers';\nimport { providerChannels } from '@src/saga/channels';\nimport { makeWorker, makeWorkerId } from '@src/saga/sagaUtils';\nimport { createWorker } from '@src/saga/workers/helpers';\nimport { StrIdx } from '@src/types';\nimport { Task } from 'redux-saga';\nimport { apply, spawn } from 'redux-saga/effects';\n\nexport function* spawnWorkers(\n  providerId: string,\n  currentWorkers: string[],\n  maxNumOfWorkers: number,\n) {\n  const providerChannel = yield apply(\n    providerChannels,\n    providerChannels.createChannel,\n    [providerId],\n  );\n\n  const workers: StrIdx<IWorker> = {};\n\n  for (\n    let workerNumber = currentWorkers.length;\n    workerNumber < maxNumOfWorkers;\n    workerNumber++\n  ) {\n    const workerId = makeWorkerId(providerId, workerNumber);\n    const workerTask: Task = yield spawn(\n      createWorker,\n      workerId,\n      providerId,\n      providerChannel,\n    );\n\n    workers[workerId] = makeWorker(providerId, workerTask);\n  }\n\n  return { workers, workerIds: [...currentWorkers, ...Object.keys(workers)] };\n}\n","import { getProviderTimeoutThreshold } from '@src/ducks/providerConfigs';\nimport { providerStorage } from '@src/providers/providerStorage';\nimport { logger } from '@src/utils/logging';\nimport { delay } from 'redux-saga';\nimport { apply, call, race, select } from 'redux-saga/effects';\n\n/**\n * @description polls the offline state of a provider, then returns control to caller when it comes back online\n * @param {string} providerId\n */\nexport function* checkProviderConnectivity(providerId: string) {\n  const provider = providerStorage.getInstance(providerId);\n  const timeoutThreshold: ReturnType<\n    typeof getProviderTimeoutThreshold\n  > = yield select(getProviderTimeoutThreshold, providerId);\n  try {\n    const { lb } = yield race({\n      lb: apply(provider, provider.getCurrentBlock),\n      to: call(delay, timeoutThreshold),\n    });\n    return !!lb;\n  } catch (error) {\n    logger.log(error);\n  }\n  return false;\n}\n","import {\n  ProcessedProvider,\n  providerOffline,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { IProviderConfig } from '@src/ducks/providerConfigs';\nimport { makeProviderStats, trackTime } from '@src/saga/sagaUtils';\nimport { spawnWorkers } from '@src/saga/workers';\nimport { call, put } from 'redux-saga/effects';\nimport { checkProviderConnectivity } from './connectivity';\n\n/**\n *\n * @description Handles checking if a provider is online or not,\n * and spawning workers for its concurrency rating\n * @param {string} providerId\n * @param {ProviderConfig} config\n */\nexport function* processProvider(\n  providerId: string,\n  { concurrency }: IProviderConfig,\n) {\n  const timer = trackTime();\n  const providerIsOnline: boolean = yield call(\n    checkProviderConnectivity,\n    providerId,\n  );\n\n  const stats = makeProviderStats(timer, !providerIsOnline);\n\n  if (!providerIsOnline) {\n    yield put(providerOffline({ providerId }));\n  }\n\n  const { workers, workerIds } = yield call(\n    spawnWorkers,\n    providerId,\n    stats.currWorkersById,\n    concurrency,\n  );\n\n  stats.currWorkersById = workerIds;\n\n  const processedProvider: ProcessedProvider = { providerId, stats, workers };\n  return processedProvider;\n}\n","import { BALANCER } from '@src/ducks/providerBalancer/balancerConfig';\nimport { getNetwork } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  ProcessedProvider,\n  providerAdded,\n} from '@src/ducks/providerBalancer/providerStats';\nimport {\n  IAddProviderConfig,\n  PROVIDER_CONFIG,\n} from '@src/ducks/providerConfigs/types';\nimport { processProvider } from '@src/saga/helpers/processing';\nimport { call, put, race, select, take, takeEvery } from 'redux-saga/effects';\n\nfunction* handleAddingProviderConfig({\n  payload: { config, id },\n}: IAddProviderConfig) {\n  const network: ReturnType<typeof getNetwork> = yield select(getNetwork);\n  if (network !== config.network) {\n    return;\n  }\n\n  const {\n    processedProvider,\n  }: { processedProvider: ProcessedProvider } = yield race({\n    processedProvider: call(processProvider, id, config),\n    cancelled: take(BALANCER.NETWORK_SWTICH_REQUESTED),\n  });\n\n  if (!processedProvider) {\n    return;\n  }\n\n  yield put(providerAdded(processedProvider));\n}\n\nexport const addProviderConfigWatcher = [\n  takeEvery(PROVIDER_CONFIG.ADD, handleAddingProviderConfig),\n];\n","import {\n  BALANCER,\n  balancerFlush,\n  IBalancerManualSucceeded,\n  IBalancerNetworkSwitchRequested,\n  IBalancerQueueTimeout,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { getWorkers } from '@src/ducks/providerBalancer/workers';\nimport { balancerChannel, providerChannels } from '@src/saga/channels';\nimport { SagaIterator } from 'redux-saga';\nimport {\n  apply,\n  call,\n  cancel,\n  put,\n  select,\n  takeEvery,\n} from 'redux-saga/effects';\n\nfunction* clearWorkers(): SagaIterator {\n  const workers: ReturnType<typeof getWorkers> = yield select(getWorkers);\n  for (const worker of Object.values(workers)) {\n    yield cancel(worker.task);\n  }\n}\n\nfunction* clearAllPendingCalls(): SagaIterator {\n  yield apply(providerChannels, providerChannels.cancelPendingCalls);\n  yield apply(balancerChannel, balancerChannel.cancelPendingCalls);\n}\n\nfunction* deleteProviderChannels() {\n  yield apply(providerChannels, providerChannels.deleteAllChannels);\n}\n\ntype FlushingActions =\n  | IBalancerQueueTimeout\n  | IBalancerNetworkSwitchRequested\n  | IBalancerManualSucceeded;\n\nfunction* clearState({ type }: FlushingActions): SagaIterator {\n  const isNetworkSwitch = type === BALANCER.NETWORK_SWTICH_REQUESTED;\n  yield call(clearAllPendingCalls);\n\n  if (isNetworkSwitch) {\n    yield put(balancerFlush());\n    yield call(clearWorkers);\n    yield call(deleteProviderChannels);\n  }\n}\n\nexport const balancerFlushWatcher = [\n  takeEvery(\n    [\n      BALANCER.NETWORK_SWTICH_REQUESTED,\n      BALANCER.QUEUE_TIMEOUT,\n      BALANCER.MANUAL_SUCCEEDED,\n    ],\n    clearState,\n  ),\n];\n","/**\n * @name filterAgainstArray\n * @description Compares each entry in arr1 against all entries in arr2, if the entry in arr1 matches an entry in arr2 then it is included in the result\n * @param arr1 An array of entries\n * @param arr2 An array of strings to check each entry against\n * @param invert Includes results from arr1 that arent in arr2 instead\n */\nexport const filterAgainstArr = <T>(\n  arr1: T[],\n  arr2: T[],\n  invert: boolean = false,\n) =>\n  arr1.filter(\n    strToCheck =>\n      !invert ? arr2.includes(strToCheck) : !arr2.includes(strToCheck),\n  );\n","import {\n  getManualMode,\n  getNetwork,\n} from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  getPendingProviderCallsByProviderId,\n  IProviderCall,\n  IProviderCallTimeout,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport {\n  getOnlineProviders,\n  getProviderStatsById,\n} from '@src/ducks/providerBalancer/providerStats';\nimport {\n  getProviderConfigById,\n  getProviderConfigs,\n  IProviderConfig,\n  providerSupportsMethod,\n} from '@src/ducks/providerConfigs';\nimport { filterAgainstArr } from '@src/ducks/utils';\nimport { allRPCMethods } from '@src/providers/constants';\nimport { AllProviderMethods, RootState, StrIdx } from '@src/types';\n\nexport const providerExceedsRequestFailureThreshold = (\n  state: RootState,\n  { payload }: IProviderCallTimeout,\n) => {\n  const { providerCall: { providerId } } = payload;\n  const providerStats = getProviderStatsById(state, providerId);\n  const providerConfig = getProviderConfigById(state, providerId);\n\n  if (!providerStats || !providerConfig) {\n    throw Error('Could not find provider stats or config');\n  }\n\n  // if the provider has reached maximum failures, declare it as offline\n  return (\n    providerStats.requestFailures >= providerConfig.requestFailureThreshold\n  );\n};\n\nexport const getAllProvidersOfNetwork = (\n  state: RootState,\n  networkId: string,\n) => {\n  const allProvidersOfNetworkId: StrIdx<IProviderConfig> = {};\n\n  const providerConfigs = getProviderConfigs(state);\n\n  return Object.entries(providerConfigs).reduce(\n    (allProviders, [currProviderId, currProviderConfig]) => {\n      if (currProviderConfig.network !== networkId) {\n        return allProviders;\n      }\n      return { ...allProviders, [currProviderId]: currProviderConfig };\n    },\n    allProvidersOfNetworkId,\n  );\n};\n\nexport const getOnlineProviderIdsOfCurrentNetwork = (state: RootState) => {\n  const network = getNetwork(state);\n  const onlineProviders = getOnlineProviders(state);\n  const providersOfCurrentNetwork = Object.keys(onlineProviders).filter(id => {\n    const config = getProviderConfigById(state, id);\n    return config && config.network === network;\n  });\n  return providersOfCurrentNetwork;\n};\n\nexport const getAllMethodsAvailable = (state: RootState): boolean => {\n  const availableProviderIds = getOnlineProviderIdsOfCurrentNetwork(state);\n  const manualProvider = getManualMode(state);\n\n  // goes through each available provider and reduces all of their\n  // available methods into a mapping that contains all supported methods\n  const availableMethods: { [key in AllProviderMethods]: boolean } = {\n    getNetVersion: false,\n    estimateGas: false,\n    getBalance: false,\n    getCurrentBlock: false,\n    getTransactionCount: false,\n    ping: false,\n    sendCallRequest: false,\n    sendCallRequests: false,\n    sendRawTx: false,\n    getTransactionByHash: false,\n    getTransactionReceipt: false,\n\n    /* Web3 Methods*/\n    sendTransaction: false,\n    signMessage: false,\n  };\n\n  for (const providerId of availableProviderIds) {\n    const providerConfig = getProviderConfigById(state, providerId);\n    if (!providerConfig) {\n      continue;\n    }\n\n    if (manualProvider && providerId !== manualProvider) {\n      continue;\n    }\n\n    // for the current provider config, OR each rpcMethod against the map\n    Object.entries(providerConfig.supportedMethods).forEach(\n      ([rpcMethod, isSupported]: [AllProviderMethods, boolean]) => {\n        availableMethods[rpcMethod] =\n          availableMethods[rpcMethod] || isSupported;\n      },\n    );\n  }\n\n  // check that all methods are supported by the set of all available providers\n  return allRPCMethods.reduce(\n    (allAvailable, curMethod) => allAvailable && availableMethods[curMethod],\n    true,\n  );\n};\n\n// available providers -> providers that support the method -> providers that are whitelisted -> prioritized providers -> workers not busy\n// TODO: include response time in prioritization\nexport const getAvailableProviderId = (\n  state: RootState,\n  payload: IProviderCall,\n) => {\n  const onlineProviders = getOnlineProviderIdsOfCurrentNetwork(state);\n\n  // filter by providers that can support this method\n  const supportsMethod = onlineProviders.filter(providerId =>\n    providerSupportsMethod(state, providerId, payload.rpcMethod),\n  );\n\n  // filter providers that are in the whitelist if it exists, else continue with providers that support the method\n  const payloadProviderWhitelist = payload.providerWhiteList;\n  const isWhitelisted = payloadProviderWhitelist\n    ? filterAgainstArr(supportsMethod, payloadProviderWhitelist)\n    : supportsMethod;\n\n  // grab the providers that are not included in min priority\n  const prioritized1 = filterAgainstArr(\n    isWhitelisted,\n    payload.minPriorityProviderList,\n    true,\n  );\n\n  // grab the providers that are included\n  const prioritized2 = filterAgainstArr(\n    isWhitelisted,\n    payload.minPriorityProviderList,\n  );\n\n  // prioritize the list by using providers with most workers free\n  const listToPrioritizeByWorker =\n    prioritized1.length > 0 ? prioritized1 : prioritized2;\n\n  let prevProvider: {\n    providerId: string;\n    numOfRequestsCurrentProcessing: number;\n  } | null = null;\n\n  for (const currentProviderId of listToPrioritizeByWorker) {\n    const numOfRequestsCurrentProcessing = getPendingProviderCallsByProviderId(\n      state,\n      currentProviderId,\n    );\n\n    // if there's no selected provider yet (aka first iteration)\n    // or\n    // the current provider has less requests processing, switch the next provider to current provider\n    if (\n      !prevProvider ||\n      prevProvider.numOfRequestsCurrentProcessing >\n        numOfRequestsCurrentProcessing\n    ) {\n      prevProvider = {\n        providerId: currentProviderId,\n        numOfRequestsCurrentProcessing,\n      };\n    }\n  }\n\n  return prevProvider ? prevProvider.providerId : null;\n};\n","import {\n  BALANCER,\n  IBalancerAuto,\n  IBalancerManualSucceeded,\n  IBalancerNetworkSwitchRequested,\n  IBalancerNetworkSwitchSucceeded,\n  setOffline,\n  setOnline,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { isOffline } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  PROVIDER_STATS,\n  ProviderStatsAction,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { getAllMethodsAvailable } from '@src/ducks/selectors';\nimport { buffers, SagaIterator } from 'redux-saga';\nimport {\n  actionChannel,\n  call,\n  fork,\n  put,\n  select,\n  take,\n} from 'redux-saga/effects';\n\ntype WatchedActions =\n  | ProviderStatsAction\n  | IBalancerNetworkSwitchRequested\n  | IBalancerNetworkSwitchSucceeded\n  | IBalancerAuto\n  | IBalancerManualSucceeded;\n\nfunction* dispatchOffline() {\n  const offline: ReturnType<typeof isOffline> = yield select(isOffline);\n  if (!offline) {\n    return yield put(setOffline());\n  }\n}\n\nfunction* dispatchOnline() {\n  const offline: ReturnType<typeof isOffline> = yield select(isOffline);\n  const online = !offline;\n  if (!online) {\n    return yield put(setOnline());\n  }\n}\n\nfunction* setBalancerOnlineState({ type }: WatchedActions): SagaIterator {\n  if (type === BALANCER.NETWORK_SWTICH_REQUESTED) {\n    yield call(dispatchOffline);\n    //block until network switch is done\n    return yield take(BALANCER.NETWORK_SWITCH_SUCCEEDED);\n  }\n\n  // check if all methods are available after this provider is online\n  const isAllMethodsAvailable: ReturnType<\n    typeof getAllMethodsAvailable\n  > = yield select(getAllMethodsAvailable);\n\n  // if they are, put app in online state\n  if (isAllMethodsAvailable) {\n    yield call(dispatchOnline);\n  } else {\n    yield call(dispatchOffline);\n  }\n}\n\nfunction* handleBalancerHealth() {\n  const chan = yield actionChannel(\n    [\n      PROVIDER_STATS.ONLINE,\n      PROVIDER_STATS.OFFLINE,\n      PROVIDER_STATS.ADDED,\n      PROVIDER_STATS.REMOVED,\n      BALANCER.NETWORK_SWITCH_SUCCEEDED,\n      BALANCER.NETWORK_SWTICH_REQUESTED,\n      BALANCER.AUTO,\n      BALANCER.MANUAL_SUCCEEDED,\n    ],\n    buffers.expanding(50),\n  );\n  while (true) {\n    const action = yield take(chan);\n    yield call(setBalancerOnlineState, action);\n  }\n}\n\nexport const balancerHealthWatcher = [fork(handleBalancerHealth)];\n","import { callMeetsBalancerRetryThreshold } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  IProviderCall,\n  IProviderCallTimeout,\n  PROVIDER_CALL,\n  providerCallFailed,\n  providerCallRequested,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { providerOffline } from '@src/ducks/providerBalancer/providerStats';\nimport { providerExceedsRequestFailureThreshold } from '@src/ducks/selectors';\nimport { createRetryCall } from '@src/saga/sagaUtils';\nimport { put, select, takeEvery } from 'redux-saga/effects';\n\nfunction* handleCallTimeouts(action: IProviderCallTimeout) {\n  const { payload: { error, providerCall } } = action;\n  const { providerId } = providerCall;\n\n  const shouldSetProviderOffline: ReturnType<\n    typeof providerExceedsRequestFailureThreshold\n  > = yield select(providerExceedsRequestFailureThreshold, action);\n\n  if (shouldSetProviderOffline) {\n    yield put(providerOffline({ providerId }));\n  }\n\n  const callFailed: ReturnType<\n    typeof callMeetsBalancerRetryThreshold\n  > = yield select(callMeetsBalancerRetryThreshold, action);\n\n  if (callFailed) {\n    yield put(providerCallFailed({ error: error.message, providerCall }));\n  } else {\n    const nextProviderCall: IProviderCall = createRetryCall(providerCall);\n    yield put(providerCallRequested(nextProviderCall));\n  }\n}\n\nexport const callTimeoutWatcher = [\n  takeEvery(PROVIDER_CALL.TIMEOUT, handleCallTimeouts),\n];\n","import {\n  BALANCER,\n  balancerNetworkSwitchRequested,\n  IBalancerManualRequested,\n  setManualFailed,\n  setManualSucceeded,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { getNetwork } from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport { getProviderConfigById } from '@src/ducks/providerConfigs';\nimport { AllActions } from '@src/ducks/types';\nimport { checkProviderConnectivity } from '@src/saga/helpers/connectivity';\nimport { logger } from '@src/utils/logging';\nimport { SagaIterator } from 'redux-saga';\nimport { call, put, select, take, takeEvery } from 'redux-saga/effects';\n\nfunction* attemptManualMode(\n  providerId: string,\n  skipOfflineCheck: boolean,\n): SagaIterator {\n  const config: ReturnType<typeof getProviderConfigById> = yield select(\n    getProviderConfigById,\n    providerId,\n  );\n\n  if (!config) {\n    return yield put(\n      setManualFailed({\n        error: `Provider config for ${providerId} not found`,\n      }),\n    );\n  }\n\n  const isOnline: boolean = yield call(checkProviderConnectivity, providerId);\n\n  if (!isOnline && !skipOfflineCheck) {\n    return yield put(\n      setManualFailed({\n        error: `${providerId} to manually set to is not online`,\n      }),\n    );\n  }\n\n  const network: ReturnType<typeof getNetwork> = yield select(getNetwork);\n\n  if (config.network !== network) {\n    logger.log(`Manually set provider ${providerId} has a different network\n      (Provider network: ${config.network}, current network ${network}).\n       Setting new network`);\n    const requestAction = balancerNetworkSwitchRequested({\n      network: config.network,\n    });\n    yield put(requestAction);\n    yield take((action: AllActions) => {\n      if (action.type === BALANCER.NETWORK_SWITCH_SUCCEEDED) {\n        return action.meta.id === requestAction.meta.id;\n      }\n      return false;\n    });\n  }\n\n  yield put(setManualSucceeded({ providerId }));\n}\n\nfunction* handleManualMode({\n  payload: { providerId, skipOfflineCheck },\n}: IBalancerManualRequested): SagaIterator {\n  yield call(attemptManualMode, providerId, skipOfflineCheck);\n}\n\nexport const manualModeWatcher = [\n  takeEvery(BALANCER.MANUAL_REQUESTED, handleManualMode),\n];\n","import { ProcessedProvider } from '@src/ducks/providerBalancer/providerStats';\nimport { getAllProvidersOfNetwork } from '@src/ducks/selectors';\nimport { processProvider } from '@src/saga/helpers/processing';\nimport { reduceProcessedProviders } from '@src/saga/sagaUtils';\nimport { all, call, select } from 'redux-saga/effects';\n\n/**\n * @description Gets all of the providers of the requested next network,\n * then creates all of the workers and provider statistics required for a successful switch\n * @param network\n */\nexport function* initializeNewNetworkProviders(network: string) {\n  const providers: ReturnType<typeof getAllProvidersOfNetwork> = yield select(\n    getAllProvidersOfNetwork,\n    network,\n  );\n\n  const providerEntries = Object.entries(providers).map(\n    ([providerId, providerConfig]) =>\n      call(processProvider, providerId, providerConfig),\n  );\n\n  // process adding all providers in parallel\n  const processedProviders: ProcessedProvider[] = yield all(providerEntries);\n  const networkSwitchPayload = reduceProcessedProviders(\n    processedProviders,\n    network,\n  );\n\n  return networkSwitchPayload;\n}\n","import {\n  BALANCER,\n  balancerNetworkSwitchSucceeded,\n  IBalancerInit,\n  IBalancerNetworkSwitchRequested,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport { logger } from '@src/utils/logging';\nimport { buffers, SagaIterator } from 'redux-saga';\nimport { actionChannel, call, fork, put, take } from 'redux-saga/effects';\nimport { initializeNewNetworkProviders } from './helpers';\n\nfunction* handleNetworkSwitch({\n  payload,\n  meta,\n}: IBalancerNetworkSwitchRequested | IBalancerInit): SagaIterator {\n  const networkSwitchPayload = yield call(\n    initializeNewNetworkProviders,\n    payload.network,\n  );\n  logger.log(`Network switch to ${payload.network} succeeded`);\n\n  yield put(balancerNetworkSwitchSucceeded(networkSwitchPayload, meta.id));\n}\n\nfunction* networkSwitchActionChannel() {\n  const chan = yield actionChannel(\n    [BALANCER.NETWORK_SWTICH_REQUESTED, BALANCER.INIT],\n    buffers.expanding(50),\n  );\n  while (true) {\n    const action: IBalancerNetworkSwitchRequested | IBalancerInit = yield take(\n      chan,\n    );\n    logger.log(`Taking action ${JSON.stringify(action, null, 1)}`);\n    yield call(handleNetworkSwitch, action);\n  }\n}\n\n// we dont use takeevery here to avoid processing two switch requests at the same time\nexport const watchNetworkSwitches = [fork(networkSwitchActionChannel)];\n","import {\n  BALANCER,\n  balancerQueueTimeout,\n} from '@src/ducks/providerBalancer/balancerConfig';\nimport {\n  getQueueTimeout,\n  isOffline,\n} from '@src/ducks/providerBalancer/balancerConfig/selectors';\nimport {\n  IProviderCallRequested,\n  providerCallFailed,\n} from '@src/ducks/providerBalancer/providerCalls';\nimport { getAvailableProviderId } from '@src/ducks/selectors';\nimport { balancerChannel, providerChannels } from '@src/saga/channels';\nimport { delay, SagaIterator } from 'redux-saga';\nimport { apply, call, fork, put, race, select, take } from 'redux-saga/effects';\n\nfunction* getOptimalProviderId(\n  payload: IProviderCallRequested['payload'],\n): SagaIterator {\n  // check if the app is offline\n  if (yield select(isOffline)) {\n    yield take(BALANCER.ONLINE); // wait until its back online\n  }\n\n  // get an available providerId to put the action to the channel\n  const providerId: ReturnType<typeof getAvailableProviderId> = yield select(\n    getAvailableProviderId,\n    payload,\n  );\n\n  if (!providerId) {\n    // TODO: seperate this into a different action\n    const action = providerCallFailed({\n      providerCall: { ...payload, providerId: 'SHEPHERD' },\n      error: 'No available provider found',\n    });\n    yield put(action);\n    return undefined;\n  }\n\n  return providerId;\n}\n\nfunction* handleRequest(): SagaIterator {\n  yield apply(balancerChannel, balancerChannel.init);\n\n  while (true) {\n    // test if this starts queue timeout\n    const action: IProviderCallRequested = yield apply(\n      balancerChannel,\n      balancerChannel.take,\n    );\n\n    function* process() {\n      if (!action) {\n        return;\n      }\n      const { payload } = action;\n      const providerId: string | undefined = yield call(\n        getOptimalProviderId,\n        payload,\n      );\n\n      if (providerId) {\n        yield apply(providerChannels, providerChannels.put, [\n          providerId,\n          action,\n        ]);\n      }\n    }\n\n    const queueTimeoutMs: ReturnType<typeof getQueueTimeout> = yield select(\n      getQueueTimeout,\n    );\n\n    const { queueTimeout } = yield race({\n      processed: call(process),\n      // we cancel in case of a balancer flush\n      // so we dont put an action that's about to be flushed\n      // to a worker\n      networkSwitch: take(BALANCER.FLUSH),\n      queueTimeout: call(delay, queueTimeoutMs),\n    });\n\n    if (queueTimeout) {\n      console.error('Queue timeout');\n      yield put(balancerQueueTimeout());\n    }\n  }\n}\n\nexport const providerRequestWatcher = [fork(handleRequest)];\n","import { BALANCER } from '@src/ducks/providerBalancer/balancerConfig';\nimport {\n  getProviderStatsById,\n  PROVIDER_STATS,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { checkProviderConnectivity } from '@src/saga/helpers/connectivity';\nimport { delay, SagaIterator } from 'redux-saga';\nimport { call, select, take } from 'redux-saga/effects';\n\nexport function* pollProviderUntilConnected(providerId: string): SagaIterator {\n  while (true) {\n    yield call(delay, 5000);\n\n    const connected: boolean = yield call(\n      checkProviderConnectivity,\n      providerId,\n    );\n    if (connected) {\n      return true;\n    }\n  }\n}\n\n/**\n * @description waits for any action that adds to the provider stats reducer,\n * and only returns when the specified provider exists\n * @param providerId\n */\nexport function* waitForProviderStatsToExist(providerId: string) {\n  while (true) {\n    const stats: ReturnType<typeof getProviderStatsById> = yield select(\n      getProviderStatsById,\n      providerId,\n    );\n    if (stats) {\n      return true;\n    }\n    yield take([BALANCER.NETWORK_SWITCH_SUCCEEDED, PROVIDER_STATS.ADDED]);\n  }\n}\n","import { BALANCER } from '@src/ducks/providerBalancer/balancerConfig';\nimport {\n  IProviderStatsOffline,\n  PROVIDER_STATS,\n  providerOnline,\n} from '@src/ducks/providerBalancer/providerStats';\nimport { call, put, race, take, takeEvery } from 'redux-saga/effects';\nimport {\n  pollProviderUntilConnected,\n  waitForProviderStatsToExist,\n} from './helpers';\n\nfunction* watchOfflineProvider({\n  payload: { providerId },\n}: IProviderStatsOffline) {\n  yield call(pollProviderUntilConnected, providerId);\n  // handles failure case of:\n  // network switch requested\n  // provider isnt online so this fires\n  // provider is online before network switch is successful\n  // this puts an action to a non existent provider id\n  yield call(waitForProviderStatsToExist, providerId);\n  yield put(providerOnline({ providerId }));\n  return true;\n}\n\nfunction* handleWatching(action: IProviderStatsOffline) {\n  yield race({\n    online: call(watchOfflineProvider, action),\n    networkSwitched: take(BALANCER.NETWORK_SWTICH_REQUESTED),\n  });\n}\n\nexport const providerHealthWatcher = [\n  takeEvery(PROVIDER_STATS.OFFLINE, handleWatching),\n];\n","import { subscriptionWatcher } from './watchActionSubscription';\nimport { addProviderConfigWatcher } from './watchAddingProviders';\nimport { balancerFlushWatcher } from './watchBalancerFlush';\nimport { balancerHealthWatcher } from './watchBalancerHealth';\nimport { callTimeoutWatcher } from './watchCallTimeouts';\nimport { manualModeWatcher } from './watchManualMode';\nimport { watchNetworkSwitches } from './watchNetworkSwitches';\nimport { providerRequestWatcher } from './watchProviderCalls';\nimport { providerHealthWatcher } from './watchProviderHealth';\n\nexport const watchers = [\n  ...watchNetworkSwitches,\n\n  ...subscriptionWatcher,\n  ...addProviderConfigWatcher,\n  ...balancerFlushWatcher,\n  ...callTimeoutWatcher,\n  ...providerRequestWatcher,\n  ...providerHealthWatcher,\n  ...balancerHealthWatcher,\n  ...manualModeWatcher,\n];\n","import { watchers } from '@src/saga/watchers';\nimport { all } from 'redux-saga/effects';\n\nexport function* providerBalancer() {\n  yield all(watchers);\n}\n","import { filterMiddlware } from '@src/ducks/middleware';\nimport {\n  providerBalancer,\n  providerBalancerSelectors,\n} from '@src/ducks/providerBalancer';\nimport { providerConfigs } from '@src/ducks/providerConfigs';\nimport * as providerConfigsSelectors from '@src/ducks/providerConfigs/selectors';\nimport { storeManager } from '@src/ducks/store';\nimport { RootState } from '@src/types';\nimport { applyMiddleware, combineReducers, createStore } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport { composeWithDevTools } from 'remote-redux-devtools';\nimport { providerBalancer as providerBalancerSaga } from '../saga';\nimport * as rootSelectors from './selectors';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst composeEnhancers = composeWithDevTools({\n  realtime: true,\n  port: 8000,\n  maxAge: 300,\n});\n\nconst rootReducer = combineReducers<RootState>({\n  providerBalancer,\n  providerConfigs,\n});\n\nconst middleware = process.env.DEV_TOOLS\n  ? composeEnhancers(applyMiddleware(sagaMiddleware, filterMiddlware))\n  : applyMiddleware(sagaMiddleware, filterMiddlware);\n\nconst store = createStore<RootState>(rootReducer, middleware);\nstoreManager.setStore(store);\n\nconst INITIAL_ROOT_STATE = rootReducer(undefined as any, {} as any);\n\nsagaMiddleware.run(providerBalancerSaga);\n\nconst selectors = {\n  rootSelectors,\n  providerBalancerSelectors,\n  providerConfigsSelectors,\n};\n\nexport {\n  filterMiddlware as shepherdMiddlware,\n  providerBalancerSaga,\n  rootReducer,\n  store,\n  INITIAL_ROOT_STATE,\n  selectors,\n};\n"],"names":["INITIAL_STATE","handleNetworkSwitch","handleWorkerKilled","handleWorkerSpawned","handleProviderAdded","handleProviderCallTimeout","handleProviderCallSucceeded","handleWorkerProcessing","BN","Validator","randomBytes","btoa","URLSearchParams","combineReducers","take","takeEvery","put","apply","flush","actionChannel","buffers","call","channel","select","race","delay","cancelled","spawn","cancel","fork","all","providerBalancer","createSagaMiddleware","composeWithDevTools","applyMiddleware","createStore","providerBalancerSaga"],"mappings":"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"}